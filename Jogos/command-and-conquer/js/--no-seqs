$(function() {
    var canvas = $("#canvas")[0], context = canvas.getContext("2d"), mouse = {
        x: 0,
        y: 0,
        gridX: 0,
        gridY: 0,
        gameX: 0,
        gameY: 0,
        insideCanvas: !1,
        panDirection: "",
        panningThreshold: 48,
        panningVelocity: 24,
        handlePanning: function() {
            var panDirection = "";
            mouse.insideCanvas && (mouse.y > game.viewportTop + mouse.panningThreshold || mouse.y < game.viewportTop ? mouse.y < game.viewportTop + game.viewportHeight - mouse.panningThreshold || mouse.y > game.viewportTop + game.viewportHeight ? (game.viewportDeltaY = 0, panDirection += "") : (game.viewportDeltaY = mouse.panningVelocity, panDirection += "_bottom") : (game.viewportDeltaY = -mouse.panningVelocity, panDirection += "_top"), mouse.x >= mouse.panningThreshold || mouse.y < game.viewportTop || mouse.y > game.viewportTop + game.viewportHeight ? mouse.x <= game.screenWidth - mouse.panningThreshold || mouse.y < game.viewportTop || mouse.y > game.viewportTop + game.viewportHeight ? (game.viewportDeltaX = 0, panDirection += "") : (game.viewportDeltaX = mouse.panningVelocity, panDirection += "_right") : (game.viewportDeltaX = -mouse.panningVelocity, panDirection += "_left"));
            if (game.viewportX + game.viewportDeltaX < 0 || game.viewportX + game.viewportDeltaX + game.screenWidth > game.currentLevel.mapImage.width) game.viewportDeltaX = 0;
            if (game.viewportY + game.viewportDeltaY < 0 || game.viewportY + game.viewportDeltaY + game.viewportHeight > game.currentLevel.mapImage.height) game.viewportDeltaY = 0;
            panDirection != "" && (game.viewportDeltaX == 0 && game.viewportDeltaY == 0 ? panDirection = "no_pan" + panDirection : panDirection = "pan" + panDirection), mouse.panDirection = panDirection, game.viewportX += game.viewportDeltaX, game.viewportY += game.viewportDeltaY, mouse.gameX = mouse.x + game.viewportX - game.viewportLeft, mouse.gameY = mouse.y + game.viewportY - game.viewportTop, game.viewportAdjustX = game.viewportLeft - game.viewportX, game.viewportAdjustY = game.viewportTop - game.viewportY;
        },
        cursorLoop: 0,
        drawCursor: function() {
            if (!this.insideCanvas) return;
            this.cursorLoop++, this.cursorLoop >= this.cursor.cursorSpeed * this.cursor.images.length && (this.cursorLoop = 0);
            if (this.dragSelect) {
                var x = Math.min(this.gameX, this.dragX), y = Math.min(this.gameY, this.dragY), width = Math.abs(this.gameX - this.dragX), height = Math.abs(this.gameY - this.dragY);
                context.strokeStyle = "white", context.strokeRect(x + game.viewportAdjustX, y + game.viewportAdjustY, width, height);
            }
            var image = this.cursor.images[Math.floor(this.cursorLoop / this.cursor.cursorSpeed)];
            context.drawImage(image, this.x - this.cursor.x, this.y - this.cursor.y);
        },
        checkOverObject: function() {
            this.overObject = null;
            for (var i = game.units.length - 1; i >= 0; i--) if (game.units[i].underPoint && game.units[i].underPoint(this.gameX, this.gameY)) {
                this.overObject = game.units[i];
                break;
            }
            for (var i = game.buildings.length - 1; i >= 0; i--) if (game.buildings[i].underPoint(this.gameX, this.gameY)) {
                this.overObject = game.buildings[i];
                break;
            }
            for (var i = game.turrets.length - 1; i >= 0; i--) if (game.turrets[i].underPoint(this.gameX, this.gameY)) {
                this.overObject = game.turrets[i];
                break;
            }
            return this.overObject;
        },
        draw: function() {
            this.cursor = this.cursors["default"];
            var selectedObject = this.checkOverObject();
            if (this.y >= game.viewportTop && this.y <= game.viewportTop + game.viewportHeight) if (sidebar.deployMode) {
                var buildingType = buildings.types[sidebar.deployBuilding], grid = $.extend([], buildingType.gridShape);
                grid.push(grid[grid.length - 1]);
                for (var y = 0; y < grid.length; y++) for (var x = 0; x < grid[y].length; x++) grid[y][x] == 1 && (game.obstructionGrid[mouse.gridY + y][mouse.gridX + x] == 1 ? game.highlightGrid(mouse.gridX + x, mouse.gridY + y, 1, 1, sidebar.placementRedImage) : game.highlightGrid(mouse.gridX + x, mouse.gridY + y, 1, 1, sidebar.placementWhiteImage));
            } else if (sidebar.repairMode) selectedObject && selectedObject.team == game.currentLevel.team && (selectedObject.type == "building" || selectedObject.type == "turret") && selectedObject.life < selectedObject.hitPoints ? this.cursor = this.cursors.repair : this.cursor = this.cursors.no_repair; else if (sidebar.sellMode) !selectedObject || selectedObject.team != game.currentLevel.team || selectedObject.type != "building" && selectedObject.type != "turret" ? this.cursor = this.cursors.no_sell : this.cursor = this.cursors.sell; else if (!sidebar.visible || mouse.x <= sidebar.left) this.dragSelect ? this.cursor = this.cursors["default"] : selectedObject ? selectedObject.team != game.currentLevel.team && game.selectedAttackers.length > 0 ? this.cursor = this.cursors.attack : selectedObject.selected ? selectedObject.name == "mcv" && (this.cursor = this.cursors.build_command) : this.cursor = this.cursors.select : this.panDirection && this.panDirection != "" ? this.cursor = this.cursors[this.panDirection] : game.selectedAttackers.length > 0 && (game.obstructionGrid[mouse.gridY] && game.obstructionGrid[mouse.gridY][mouse.gridX] == 1 ? this.cursor = this.cursors.no_move : this.cursor = this.cursors.move);
            this.insideCanvas && this.drawCursor();
        },
        click: function(ev, rightClick) {
            mouse.y <= game.viewportTop && mouse.y > game.viewportTop - 15 ? (mouse.x < 0 || mouse.x >= 160) && (mouse.x < 320 || mouse.x >= 480) && mouse.x >= 480 && mouse.x < 640 && (sidebar.visible = !sidebar.visible) : mouse.y >= game.viewportTop && mouse.y <= game.viewportTop + game.viewportHeight && (sidebar.visible && mouse.x > sidebar.left ? sidebar.click(ev, rightClick) : game.click(ev, rightClick));
        },
        listenEvents: function() {
            $("#canvas").mousemove(function(ev) {
                var offset = $("#canvas").offset();
                mouse.x = ev.pageX - offset.left, mouse.y = ev.pageY - offset.top, mouse.gridX = Math.floor(mouse.gameX / game.gridSize), mouse.gridY = Math.floor(mouse.gameY / game.gridSize);
                if (mouse.buttonPressed) {
                    if (Math.abs(mouse.dragX - mouse.gameX) > 5 || Math.abs(mouse.dragY - mouse.gameY) > 5) mouse.dragSelect = !0;
                } else mouse.dragSelect = !1;
            }), $("#canvas").click(function(ev) {
                return mouse.click(ev, !1), mouse.dragSelect = !1, !1;
            }), $("#canvas").mousedown(function(ev) {
                return ev.which == 1 && (mouse.buttonPressed = !0, mouse.dragX = mouse.gameX, mouse.dragY = mouse.gameY, ev.preventDefault()), !1;
            }), $("#canvas").bind("contextmenu", function(ev) {
                return mouse.click(ev, !0), !1;
            }), $("#canvas").mouseup(function(ev) {
                if (ev.which == 1) {
                    if (mouse.dragSelect) {
                        ev.shiftKey || game.clearSelection();
                        var x1 = Math.min(mouse.gameX, mouse.dragX), y1 = Math.min(mouse.gameY, mouse.dragY), x2 = Math.max(mouse.gameX, mouse.dragX), y2 = Math.max(mouse.gameY, mouse.dragY);
                        for (var i = game.units.length - 1; i >= 0; i--) {
                            var unit = game.units[i];
                            !unit.selected && unit.team == game.currentLevel.team && x1 <= unit.x * game.gridSize && x2 >= unit.x * game.gridSize && y1 <= unit.y * game.gridSize && y2 >= unit.y * game.gridSize && game.selectItem(unit);
                        }
                    }
                    mouse.buttonPressed = !1;
                }
                return !1;
            }), $("#canvas").mouseleave(function(ev) {
                mouse.insideCanvas = !1;
            }), $("#canvas").mouseenter(function(ev) {
                mouse.buttonPressed = !1, mouse.insideCanvas = !0;
            });
        },
        loaded: !1,
        preloadCount: 0,
        loadedCount: 0,
        preloadImage: preloadImage,
        loadImageArray: loadImageArray,
        cursors: {},
        loadCursor: function(name, x, y, imageCount, cursorSpeed) {
            !x && !y && (x = 0, y = 0), cursorSpeed || (cursorSpeed = 1);
            var imageArray;
            imageCount ? imageArray = this.loadImageArray("cursors/" + name, imageCount, ".gif") : imageArray = [ this.preloadImage("cursors/" + name + ".gif") ], this.cursors[name] = {
                x: x,
                y: y,
                name: name,
                images: imageArray,
                cursorSpeed: cursorSpeed
            };
        },
        loadAllCursors: function() {
            mouse.loadCursor("default"), mouse.loadCursor("no_default"), mouse.loadCursor("move", 15, 12), mouse.loadCursor("no_move", 15, 12), mouse.loadCursor("pan_top", 15, 0), mouse.loadCursor("pan_top_right", 30, 0), mouse.loadCursor("pan_right", 30, 12), mouse.loadCursor("pan_bottom_right", 30, 24), mouse.loadCursor("pan_bottom", 15, 24), mouse.loadCursor("pan_bottom_left", 0, 24), mouse.loadCursor("pan_left", 0, 12), mouse.loadCursor("pan_top_left", 0, 0), mouse.loadCursor("no_pan_top", 15, 0), mouse.loadCursor("no_pan_top_right", 30, 0), mouse.loadCursor("no_pan_right", 30, 12), mouse.loadCursor("no_pan_bottom_right", 30, 24), mouse.loadCursor("no_pan_bottom", 15, 24), mouse.loadCursor("no_pan_bottom_left", 0, 24), mouse.loadCursor("no_pan_left", 0, 12), mouse.loadCursor("no_pan_top_left", 0, 0), mouse.loadCursor("no_repair", 15, 0), mouse.loadCursor("no_sell", 15, 12), mouse.loadCursor("build_command", 15, 12, 8), mouse.loadCursor("sell", 15, 12, 24), mouse.loadCursor("repair", 15, 0, 24), mouse.loadCursor("attack", 15, 12, 8), mouse.loadCursor("big_detonate", 15, 12, 3), mouse.loadCursor("detonate", 15, 12, 3), mouse.loadCursor("load_vehicle", 15, 12, 3), mouse.loadCursor("select", 15, 12, 6, 2);
        }
    }, game = {
        screenWidth: canvas.width,
        screenHeight: canvas.height,
        viewportTop: 35,
        viewportLeft: 0,
        viewportX: 0,
        viewportY: 0,
        viewportDeltaX: 0,
        viewportDeltaY: 0,
        gridSize: 24,
        animationLoop: null,
        animationTimeout: 50,
        debugMode: !1,
        speedAdjustmentFactor: .2,
        setViewport: function() {
            context.beginPath(), this.viewportWidth = sidebar.visible ? this.screenWidth - sidebar.width : this.screenWidth, this.viewportHeight = 480, context.rect(this.viewportLeft, this.viewportTop, this.viewportWidth - this.viewportLeft, this.viewportHeight), context.clip();
        },
        drawMap: function() {
            mouse.handlePanning(), context.drawImage(this.currentLevel.mapImage, this.viewportX, this.viewportY, this.viewportWidth, this.viewportHeight, this.viewportLeft, this.viewportTop, this.viewportWidth, this.viewportHeight), game.obstructionGrid = [];
            for (var y = 0; y < this.currentLevel.obstructionGrid.length; y++) {
                game.obstructionGrid[y] = [];
                for (var x = 0; x < this.currentLevel.obstructionGrid[y].length; x++) game.obstructionGrid[y][x] = this.currentLevel.obstructionGrid[y][x];
            }
            for (var i = this.buildings.length - 1; i >= 0; i--) {
                var bldng = this.buildings[i];
                for (var y = 0; y < bldng.gridShape.length; y++) for (var x = 0; x < bldng.gridShape[y].length; x++) bldng.gridShape[y][x] == 1 && (game.obstructionGrid[y + bldng.y][x + bldng.x] = 1);
            }
            for (var i = this.turrets.length - 1; i >= 0; i--) game.obstructionGrid[this.turrets[i].y][this.turrets[i].x] = 1;
            for (var i = this.units.length - 1; i >= 0; i--) {
                var unit = this.units[i];
                if (!unit.moving) {
                    if (unit.orders && unit.orders.type != "guard") break;
                    var x = unit.x, y = unit.y, collisionRadius = unit.collisionRadius / game.gridSize;
                    game.obstructionGrid[Math.floor(y)][Math.floor(x)] = 1, game.obstructionGrid[Math.floor(y - collisionRadius)][Math.floor(x - collisionRadius)] = 1, game.obstructionGrid[Math.floor(y - collisionRadius)][Math.floor(x + collisionRadius)] = 1, game.obstructionGrid[Math.floor(y + collisionRadius)][Math.floor(x - collisionRadius)] = 1, game.obstructionGrid[Math.floor(y + collisionRadius)][Math.floor(x + collisionRadius)] = 1;
                }
            }
            for (var i = this.overlay.length - 1; i >= 0; i--) {
                var over = this.overlay[i];
                over.name == "tree" ? game.obstructionGrid[over.y][over.x] = 1 : over.name == "trees" && (game.obstructionGrid[over.y][over.x] = 1, game.obstructionGrid[over.y][over.x + 1] = 1);
            }
        },
        highlightGrid: function(i, j, width, height, optionalImage) {
            var gridSize = game.gridSize;
            optionalImage && $(optionalImage).is("img") ? context.drawImage(optionalImage, i * gridSize + game.viewportAdjustX, j * gridSize + game.viewportAdjustY, width * gridSize, height * gridSize) : (optionalImage ? context.fillStyle = optionalImage : context.fillStyle = "rgba(225,225,225,0.5)", context.fillRect(i * gridSize + game.viewportAdjustX, j * gridSize + game.viewportAdjustY, width * gridSize, height * gridSize));
        },
        drawGrid: function() {
            var gridSize = game.gridSize, mapWidth = game.currentLevel.mapImage.width, mapHeight = game.currentLevel.mapImage.height, viewportX = game.viewportX, viewportY = game.viewportY, gridWidth = mapWidth / gridSize, gridHeight = mapHeight / gridSize;
            context.beginPath(), context.strokeStyle = "rgba(30,0,0,.6)";
            for (var i = 0; i < gridWidth; i++) context.moveTo(i * gridSize - viewportX + game.viewportLeft, 0 - viewportY + game.viewportTop), context.lineTo(i * gridSize - viewportX + game.viewportLeft, mapHeight - viewportY + game.viewportTop);
            for (var i = 0; i < gridHeight; i++) context.moveTo(0 - viewportX + game.viewportLeft, i * gridSize - viewportY + game.viewportTop), context.lineTo(mapWidth - viewportX + game.viewportLeft, i * gridSize - viewportY + game.viewportTop);
            context.stroke();
            for (var i = game.obstructionGrid.length - 1; i >= 0; i--) for (var j = game.obstructionGrid[i].length - 1; j >= 0; j--) game.obstructionGrid[i][j] == 1 && game.highlightGrid(j, i, 1, 1, "rgba(100,0,0,0.5)");
        },
        units: [],
        buildings: [],
        turrets: [],
        overlay: [],
        bullets: [],
        fireBullet: function(bullet) {
            bullet.x = bullet.x - .5 * Math.sin(bullet.angle), bullet.y = bullet.y - .5 * Math.cos(bullet.angle), bullet.range = bullet.range - .5, this.bullets.push(bullet), setTimeout(function() {
                bullet.source.bulletFiring = !1;
            }, bullet.source.reloadTime);
        },
        drawBullets: function() {
            for (var j = this.bullets.length - 1; j >= 0; j--) {
                var bullet = this.bullets[j];
                bullet.speed = 5, bullet.range = bullet.range - .1 * bullet.speed, bullet.x = bullet.x - .1 * bullet.speed * Math.sin(bullet.angle), bullet.y = bullet.y - .1 * bullet.speed * Math.cos(bullet.angle);
                var x = bullet.x * game.gridSize, y = bullet.y * game.gridSize;
                if (!bullet.dead) {
                    var overObject;
                    for (var i = game.units.length - 1; i >= 0; i--) if (game.units[i].underPoint && game.units[i].underPoint(x, y) && game.units[i].team != bullet.source.team) {
                        overObject = game.units[i];
                        break;
                    }
                    for (var i = game.buildings.length - 1; i >= 0; i--) if (game.buildings[i].underPoint(x, y)) {
                        overObject = game.buildings[i];
                        break;
                    }
                    for (var i = game.turrets.length - 1; i >= 0; i--) if (game.turrets[i].underPoint(x, y)) {
                        overObject = game.turrets[i];
                        break;
                    }
                    overObject && (bullet.dead = !0, overObject.health = overObject.health - Math.floor((bullet.damage ? bullet.damage : 10) + 10 * Math.random()), overObject.health < 0 && (overObject.status = "destroy")), context.fillStyle = "red", context.fillRect(x + game.viewportAdjustX, y + game.viewportAdjustY, 2, 2);
                }
                bullet.range <= 0 && this.bullets.splice(j, 1);
            }
        },
        drawObjects: function() {
            var objects = [];
            for (var i = this.buildings.length - 1; i >= 0; i--) this.buildings[i].status == "destroy" && this.buildings.splice(i, 1);
            for (var i = this.units.length - 1; i >= 0; i--) this.units[i].status == "destroy" && this.units.splice(i, 1);
            for (var i = this.turrets.length - 1; i >= 0; i--) this.turrets[i].status == "destroy" && this.turrets.splice(i, 1);
            $.merge(objects, this.units), $.merge(objects, this.buildings), $.merge(objects, this.overlay), $.merge(objects, this.turrets), objects.sort(function(a, b) {
                return b.y - a.y;
            });
            for (var i = objects.length - 1; i >= 0; i--) objects[i].draw();
        },
        moveObjects: function() {
            for (var i = this.units.length - 1; i >= 0; i--) this.units[i].processOrders && this.units[i].processOrders(), this.units[i].move();
            for (var i = this.turrets.length - 1; i >= 0; i--) this.turrets[i].processOrders && this.turrets[i].processOrders(), this.turrets[i].move();
        },
        showDebugger: function() {
            var getKeys = function(item) {
                var html = "<ul>";
                for (key in item) if (item.hasOwnProperty(key)) {
                    var o = item[key];
                    if (typeof o != "function" || o === null) typeof o == "object" ? (html += "<li>" + key + " : ", o instanceof HTMLImageElement ? html += o.src.replace(/^.+images\//, "") : o instanceof Array ? html += "Array[" + o.length + "]" : html += "Object") : html += "<li>" + key + " : " + o + "</li>";
                }
                return html += "</ul>", html;
            }, html = "";
            html += "Level", html += getKeys(levels), html += "Mouse", html += getKeys(mouse), game.selectedItems.length == 1 && (html += "Selected Item", html += getKeys(game.selectedItems[0])), html += "Game", html += getKeys(game), html += "Sidebar", html += getKeys(sidebar), html += "Vehicles", html += getKeys(vehicles), html += "Buildings", html += getKeys(buildings), html += "Infantry", html += getKeys(infantry), $("#debugger").html(html);
        },
        animate: function() {
            game.debugMode && game.showDebugger();
            if (!levels.loaded || !sidebar.loaded || !vehicles.loaded || !infantry.loaded || !buildings.loaded) {
                context.clearRect(0, 0, canvas.width, canvas.height);
                return;
            }
            context.save(), sidebar.draw(), game.setViewport(), game.drawMap(), game.debugMode && game.drawGrid(), game.moveObjects(), game.drawObjects(), game.drawBullets(), fog.draw(), context.restore(), game.drawMessage(), mouse.draw();
        },
        messageVisible: !0,
        messageHeadingVisible: !0,
        messageText: "\nCreate a base by deploying your MCV. Build a power plant and weapons factory.\n\nUse your tanks to get rid of all enemy presence in the area.",
        drawMessage: function() {
            if (!this.messageVisible) return;
            context.drawImage(sidebar.messageBox, game.viewportLeft + 22, game.viewportTop + 150), this.messageHeadingVisible || (context.fillStyle = "black", context.fillRect(265, 198, 120, 20)), context.fillStyle = "green", context.font = '16px "Command and Conquer"';
            var msgs = this.messageText.split("\n");
            for (var i = 0; i < msgs.length; i++) context.fillText(msgs[i], game.viewportLeft + 80, game.viewportTop + 200 + i * 18);
        },
        displayMessage: function(text, displayHeader) {
            this.messageText = text, this.messageVisible = !0, this.messageHeadingVisible = !!displayHeader;
        },
        missionStatus: function() {
            var heroUnits = [], heroBuildings = [], heroTurrets = [], villainBuildings = [], villainUnits = [], villainTurrets = [];
            for (var i = game.units.length - 1; i >= 0; i--) item = game.units[i], item.team == game.currentLevel.team ? heroUnits.push(item) : villainUnits.push(item);
            for (var i = game.buildings.length - 1; i >= 0; i--) item = game.buildings[i], item.team == game.currentLevel.team ? heroBuildings.push(item) : villainBuildings.push(item);
            for (var i = game.turrets.length - 1; i >= 0; i--) item = game.turrets[i], item.team == game.currentLevel.team ? heroTurrets.push(item) : villainTurrets.push(item);
            heroUnits.length == 0 && heroBuildings.length == 0 && (sounds.play("mission_failure"), game.end()), villainTurrets.length == 0 && villainBuildings.length == 0 && villainUnits.length == 0 && (sounds.play("mission_accomplished"), game.end());
        },
        selectedItems: [],
        selectedAttackers: [],
        clearSelection: function() {
            for (var i = this.selectedItems.length - 1; i >= 0; i--) this.selectedItems[i].selected = 0, this.selectedItems.splice(i, 1);
            this.selectedAttackers = [];
        },
        selectItem: function(item) {
            item.selected = !0, this.selectedItems.push(item), item.type != "building" && item.team == game.currentLevel.team && (this.selectedAttackers.push(item), sounds.play(item.type + "_select"));
        },
        click: function(ev, rightClick) {
            if (!(!game.messageVisible || mouse.x < 290 || mouse.x > 350 || mouse.y < 310 || mouse.y > 325)) {
                game.messageVisible = !1;
                return;
            }
            var selectedObject = mouse.checkOverObject();
            if (rightClick) {
                this.clearSelection(), sidebar.repairMode = !1, sidebar.deployMode = !1, sidebar.sellMode = !1;
                return;
            }
            if (sidebar.repairMode) !selectedObject || selectedObject.team != game.currentLevel.team || selectedObject.type != "building" && selectedObject.type != "turret" || selectedObject.life >= selectedObject.hitPoints; else if (sidebar.deployMode) sidebar.finishDeployingBuilding(); else if (sidebar.sellMode) selectedObject && selectedObject.team == game.currentLevel.team && (selectedObject.type == "building" || selectedObject.type == "turret") && (selectedObject.status = "sell", sounds.play("sell"), sidebar.cash += selectedObject.cost / 2); else if (!rightClick && !mouse.dragSelect) if (selectedObject) if (game.selectedAttackers.length == 1 && selectedObject.selected) selectedObject.name == "mcv" && (this.clearSelection(), selectedObject.orders = {
                type: "build"
            }); else if (selectedObject.team == game.currentLevel.team) ev.shiftKey || this.clearSelection(), this.selectItem(selectedObject); else if (game.selectedAttackers.length > 0) for (var i = game.selectedAttackers.length - 1; i >= 0; i--) game.selectedAttackers[i].primaryWeapon && (game.selectedAttackers[i].orders = {
                type: "attack",
                target: selectedObject
            }, sounds.play(game.selectedAttackers[i].type + "_move")); else ev.shiftKey || this.clearSelection(), this.selectItem(selectedObject); else if (game.selectedAttackers.length > 0) if (!game.obstructionGrid[mouse.gridY] || game.obstructionGrid[mouse.gridY][mouse.gridX] != 1) for (var i = game.selectedAttackers.length - 1; i >= 0; i--) game.selectedAttackers[i].orders = {
                type: "move",
                to: {
                    x: mouse.gridX,
                    y: mouse.gridY
                }
            }, sounds.play(game.selectedAttackers[i].type + "_move");
        },
        start: function() {
            mouse.loadAllCursors(), sounds.loadAll(), overlay.loadAll(), this.currentLevel = levels.load("gdi1"), this.overlay = this.currentLevel.overlay, sidebar.load(), mouse.listenEvents(), fog.init(), game.viewportX = 96, game.viewportY = 264, sidebar.visible = !1, this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 8,
                y: 6,
                turretDirection: 16,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 9,
                y: 3,
                turretDirection: 16,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 7,
                y: 5,
                turretDirection: 16,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 8,
                y: 2,
                turretDirection: 16,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 16,
                y: 25,
                turretDirection: 24,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 13,
                y: 26,
                turretDirection: 24,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 11,
                y: 23,
                turretDirection: 18,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 10,
                y: 24,
                turretDirection: 20,
                team: "nod"
            })), this.turrets.push(turrets.add({
                name: "gun-turret",
                x: 9,
                y: 25,
                turretDirection: 24,
                team: "nod"
            })), this.buildings.push(buildings.add({
                name: "construction-yard",
                x: 1,
                y: 14,
                team: "nod"
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 7,
                y: 6,
                team: "nod",
                orders: {
                    type: "patrol",
                    from: {
                        x: 9,
                        y: 24
                    },
                    to: {
                        x: 12,
                        y: 8
                    }
                }
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 2,
                y: 20,
                team: "nod",
                orders: {
                    type: "patrol",
                    from: {
                        x: 2,
                        y: 5
                    },
                    to: {
                        x: 6,
                        y: 20
                    }
                }
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 5,
                y: 10,
                team: "nod",
                orders: {
                    type: "patrol",
                    from: {
                        x: 17,
                        y: 12
                    },
                    to: {
                        x: 22,
                        y: 2
                    }
                }
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 2,
                y: 2,
                team: "nod",
                orders: {
                    type: "patrol",
                    from: {
                        x: 25,
                        y: 5
                    },
                    to: {
                        x: 17,
                        y: 25
                    }
                }
            })), this.units.push(vehicles.add({
                name: "mcv",
                x: 23,
                y: 23,
                moveDirection: 0
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 22,
                y: 25,
                moveDirection: 0
            })), this.units.push(vehicles.add({
                name: "light-tank",
                x: 24,
                y: 25,
                moveDirection: 0
            })), this.units.push(infantry.add({
                name: "minigunner",
                x: 27,
                y: 12,
                team: "nod"
            })), this.units.push(infantry.add({
                name: "minigunner",
                x: 28,
                y: 12,
                team: "nod"
            })), this.animationLoop = setInterval(this.animate, this.animationTimeout), this.statusLoop = setInterval(game.missionStatus, 3e3);
        },
        end: function() {
            clearInterval(this.statusLoop), sidebar.visible = !1, game.displayMessage("Thank you for trying this demo.This is still a work in progress. \nAny comments, feedback (including bugs), and advice is appreciated.\n\nIf you liked this demo, please share this page with all your friends. ");
        }
    }, sidebar = {
        loaded: !0,
        preloadCount: 0,
        loadedCount: 0,
        preloadImage: preloadImage,
        tabsImage: null,
        width: 160,
        visible: !0,
        cash: 0,
        finishDeployingBuilding: function() {
            for (var i = 0; i < game.buildings.length; i++) if (game.buildings[i].name == "construction-yard") {
                game.buildings[i].status = "construct";
                break;
            }
            game.buildings.push(buildings.add({
                name: sidebar.deployBuilding,
                x: mouse.gridX,
                y: mouse.gridY,
                status: "build"
            })), sounds.play("construction"), sidebar.deployMode = !1;
            for (var i = this.leftButtons.length - 1; i >= 0; i--) this.leftButtons[i].status = "";
            sidebar.deployBuilding = null;
        },
        finishDeployingUnit: function(unitButton) {
            var constructedAt;
            for (var i = 0; i < game.buildings.length; i++) if (game.buildings[i].name == unitButton.dependency[0]) {
                constructedAt = game.buildings[i];
                break;
            }
            unitButton.type == "infantry" ? game.units.push(infantry.add({
                name: unitButton.name,
                x: constructedAt.x + constructedAt.gridWidth / 2,
                y: constructedAt.y + constructedAt.gridHeight,
                moveDirection: 4,
                instructions: [ {
                    type: "move",
                    distance: 2
                } ]
            })) : unitButton.type == "vehicle" && (constructedAt.status = "construct", game.units.push(vehicles.add({
                name: unitButton.name,
                x: constructedAt.x + 1,
                y: constructedAt.y + 2.5,
                moveDirection: 16,
                turretDirection: 16,
                orders: {
                    type: "move",
                    to: {
                        x: Math.floor(constructedAt.x + Math.random() * 2),
                        y: Math.floor(constructedAt.y + 5 + Math.random())
                    }
                }
            })));
            for (var i = this.rightButtons.length - 1; i >= 0; i--) this.rightButtons[i].dependency[0] == unitButton.dependency[0] && (this.rightButtons[i].status = "");
            sidebar.deployBuilding = null;
        },
        click: function(ev, rightClick) {
            var clickY = mouse.y - this.top, clickX = mouse.x;
            if (clickY < 146 || clickY > 160) if (clickY < 455 || clickY > 480) {
                if (clickY >= 165 && clickY <= 455) {
                    var buttonPosition = 0;
                    for (var i = 0; i < 6; i++) if (clickY >= 165 + i * 48 && clickY <= 165 + i * 48 + 48) {
                        buttonPosition = i;
                        break;
                    }
                    var buttonSide, buttonPressedIndex, buttons;
                    clickX < 500 || clickX > 564 ? clickX >= 570 && clickX <= 634 && (buttonSide = "right", buttonPressedIndex = this.rightButtonOffset + buttonPosition, buttons = this.rightButtons) : (buttonSide = "left", buttonPressedIndex = this.leftButtonOffset + buttonPosition, buttons = this.leftButtons);
                    if (buttons && buttons.length > buttonPressedIndex) {
                        var buttonPressed = buttons[buttonPressedIndex];
                        if (buttonPressed.status == "" && !rightClick) if (buttonPressed.cost > sidebar.cash) sounds.play("insufficient_funds"); else {
                            for (var i = buttons.length - 1; i >= 0; i--) buttons[i].dependency[0] == buttonPressed.dependency[0] && (buttons[i].status = "disabled");
                            buttonPressed.status = "building", buttonPressed.counter = 0, buttonPressed.spent = buttonPressed.cost, sounds.play("building");
                        } else if (buttonPressed.status == "building" && !rightClick) sounds.play("not_ready"); else if (buttonPressed.status == "building" && rightClick) buttonPressed.status = "hold", sounds.play("on_hold"); else if (buttonPressed.status == "hold" && !rightClick) buttonPressed.status = "building", sounds.play("building"); else if (buttonPressed.status == "hold" && rightClick) {
                            buttonPressed.status = "", sounds.play("cancelled");
                            for (var i = buttons.length - 1; i >= 0; i--) buttons[i].status = "";
                        } else buttonPressed.status == "ready" && !rightClick ? buttonPressed.type == "building" && (sidebar.deployMode = !0, this.repairMode = this.sellMode = this.mapMode = !1, sidebar.deployBuilding = buttonPressed.name) : buttonPressed.status == "disabled" && sounds.play("building_in_progress");
                    }
                }
            } else clickX < 500 || clickX > 530 ? clickX < 532 || clickX > 562 ? clickX < 570 || clickX > 600 ? clickX >= 602 && clickX <= 632 && this.rightButtonOffset + 6 < this.rightButtons.length && (this.rightButtonOffset++, sounds.play("button")) : this.rightButtonOffset > 0 && (this.rightButtonOffset--, sounds.play("button")) : this.leftButtonOffset + 6 < this.leftButtons.length && (this.leftButtonOffset++, sounds.play("button")) : this.leftButtonOffset > 0 && (this.leftButtonOffset--, sounds.play("button")); else clickX < 485 || clickX > 530 ? clickX < 538 || clickX > 582 ? clickX >= 590 && clickX <= 635 && (this.mapMode = !this.mapMode, this.repairMode = this.sellMode = this.deployMode = !1) : (this.sellMode = !this.sellMode, this.repairMode = this.mapMode = this.deployMode = !1) : (this.repairMode = !this.repairMode, this.sellMode = this.mapMode = this.deployMode = !1);
        },
        allButtons: [],
        leftButtons: [],
        rightButtons: [],
        checkDependency: function() {
            for (var i = 0; i < this.allButtons.length; i++) {
                var button = this.allButtons[i], dependenciesSatisfied = !0;
                for (var j = button.dependency.length - 1; j >= 0; j--) {
                    var found = !1, dependency = button.dependency[j];
                    for (var k = game.buildings.length - 1; k >= 0; k--) {
                        var building = game.buildings[k];
                        if (building.name == dependency && building.status != "build" && building.life != "ultra-damaged" && building.team == game.currentLevel.team) {
                            found = !0;
                            break;
                        }
                    }
                    if (!found) {
                        dependenciesSatisfied = !1;
                        break;
                    }
                }
                if (button.type == "building") {
                    var buttonFound = !1, foundIndex;
                    for (var j = this.leftButtons.length - 1; j >= 0; j--) if (this.leftButtons[j].name == button.name) {
                        buttonFound = !0, foundIndex = j;
                        break;
                    }
                    if (dependenciesSatisfied && !buttonFound) this.leftButtons.push(button), button.status = "", button.counter = 0, button.speed = this.buildSpeedMultiplier / button.cost, sounds.play("new_construction_options"), sidebar.visible = !0; else if (buttonFound && !dependenciesSatisfied) {
                        if (this.leftButtons[foundIndex].status == "building" || this.leftButtons[foundIndex].status == "hold" || this.leftButtons[foundIndex].status == "ready") for (var j = this.leftButtons.length - 1; j >= 0; j--) this.leftButtons[j].status = "";
                        this.leftButtons.splice(foundIndex, 1);
                    }
                } else if (button.type == "infantry" || button.type == "vehicle") {
                    var buttonFound = !1, foundIndex;
                    for (var j = this.rightButtons.length - 1; j >= 0; j--) if (this.rightButtons[j].name == button.name) {
                        buttonFound = !0, foundIndex = j;
                        break;
                    }
                    if (dependenciesSatisfied && !buttonFound) this.rightButtons.push(button), button.status = "", button.counter = 0, button.speed = this.buildSpeedMultiplier / button.cost, sounds.play("new_construction_options"); else if (buttonFound && !dependenciesSatisfied) {
                        if (this.rightButtons[foundIndex].status == "building" || this.rightButtons[foundIndex].status == "hold" || this.rightButtons[foundIndex].status == "ready") for (var j = this.rightButtons.length - 1; j >= 0; j--) this.rightButtons[j].dependency[0] == this.rightButtons[foundIndex].dependency[0] && (this.rightButtons[j].status = "");
                        this.rightButtons.splice(foundIndex, 1);
                    }
                }
            }
        },
        load: function() {
            this.tabsImage = this.preloadImage("sidebar/tabs.png"), this.sidebarImage = this.preloadImage("sidebar/sidebar.png"), this.primaryBuildingImage = this.preloadImage("sidebar/primary.png"), this.readyImage = this.preloadImage("sidebar/ready.png"), this.holdImage = this.preloadImage("sidebar/hold.png"), this.placementWhiteImage = this.preloadImage("sidebar/placement-white.gif"), this.placementRedImage = this.preloadImage("sidebar/placement-red.gif"), this.powerIndicator = this.preloadImage("sidebar/power/power_indicator2.png"), this.messageBox = this.preloadImage("sidebar/message_box.jpg"), this.top = game.viewportTop - 2, this.left = canvas.width - this.width;
            var buttonList = [ {
                name: "power-plant",
                type: "building",
                cost: 300,
                dependency: [ "construction-yard" ]
            }, {
                name: "barracks",
                type: "building",
                cost: 300,
                dependency: [ "construction-yard", "power-plant" ]
            }, {
                name: "weapons-factory",
                type: "building",
                cost: 300,
                dependency: [ "construction-yard", "power-plant" ]
            }, {
                name: "minigunner",
                type: "infantry",
                cost: 100,
                dependency: [ "barracks" ]
            }, {
                name: "light-tank",
                type: "vehicle",
                cost: 600,
                dependency: [ "weapons-factory" ]
            } ];
            this.allButtons = [];
            for (var i = 0; i < buttonList.length; i++) {
                var button = buttonList[i];
                this.allButtons.push({
                    name: button.name,
                    image: this.preloadImage("sidebar/icons/" + button.name + "-icon.png"),
                    type: button.type,
                    status: "",
                    cost: button.cost,
                    dependency: button.dependency
                });
            }
        },
        textBrightness: 0,
        textBrightnessDelta: -.14,
        drawButtonLabel: function(labelImage, x, y) {
            var labelOffsetX = this.iconWidth / 2 - labelImage.width / 2, labelOffsetY = this.iconHeight / 2;
            context.globalAlpha = this.textBrightness, context.drawImage(labelImage, x + labelOffsetX, y + labelOffsetY), context.globalAlpha = 1;
        },
        drawButtonCost: function(cost, x, y) {
            var costOffsetX = 35, costOffsetY = 10;
            context.fillStyle = "white", context.fillText(" " + cost, x + costOffsetX, y + costOffsetY);
        },
        iconWidth: 64,
        iconHeight: 48,
        leftButtonOffset: 0,
        rightButtonOffset: 0,
        buildSpeedMultiplier: 300,
        drawButton: function(side, index) {
            var buttons = side == "left" ? this.leftButtons : this.rightButtons, offset = side == "left" ? this.leftButtonOffset : this.rightButtonOffset, button = buttons[index + offset], xOffset = side == "left" ? 500 : 570, yOffset = 165 + this.top + index * this.iconHeight;
            context.drawImage(button.image, xOffset, yOffset), button.status == "ready" ? this.drawButtonLabel(this.readyImage, xOffset, yOffset) : button.status == "disabled" ? (context.fillStyle = "rgba(200,200,200,0.6)", context.fillRect(xOffset, yOffset, this.iconWidth, this.iconHeight)) : button.status == "building" ? (spriteContext.clearRect(0, 0, this.iconWidth, this.iconHeight), spriteContext.fillStyle = "rgba(200,200,200,0.6)", spriteContext.beginPath(), spriteContext.moveTo(this.iconWidth / 2, this.iconHeight / 2), spriteContext.arc(this.iconWidth / 2, this.iconHeight / 2, 40, Math.PI * 2 * button.counter / 100 - Math.PI / 2, -Math.PI / 2), spriteContext.moveTo(this.iconWidth / 2, this.iconHeight / 2), spriteContext.fill(), context.drawImage(spriteCanvas, 0, 0, this.iconWidth, this.iconHeight, xOffset, yOffset, this.iconWidth, this.iconHeight)) : button.status == "hold" && (spriteContext.clearRect(0, 0, this.iconWidth, this.iconHeight), spriteContext.fillStyle = "rgba(100,100,100,0.6)", spriteContext.beginPath(), spriteContext.moveTo(this.iconWidth / 2, this.iconHeight / 2), spriteContext.arc(this.iconWidth / 2, this.iconHeight / 2, 40, Math.PI * 2 * button.counter / 100 - Math.PI / 2, -Math.PI / 2), spriteContext.moveTo(this.iconWidth / 2, this.iconHeight / 2), spriteContext.fill(), context.drawImage(spriteCanvas, 0, 0, this.iconWidth, this.iconHeight, xOffset, yOffset, this.iconWidth, this.iconHeight), this.drawButtonLabel(this.holdImage, xOffset, yOffset));
        },
        processButton: function(side, index) {
            var buttons = side == "left" ? this.leftButtons : this.rightButtons, offset = side == "left" ? this.leftButtonOffset : this.rightButtonOffset, button = buttons[index + offset], xOffset = side == "left" ? 500 : 570, yOffset = 165 + this.top + index * this.iconHeight;
            if (button.status == "building") {
                button.counter += button.speed, button.spent -= Math.round(button.cost * button.speed / 100), this.cash -= Math.round(button.cost * button.speed / 100);
                if (button.counter > 99) {
                    this.cash -= button.spent, button.status = "ready";
                    if (side == "left") sounds.play("construction_complete"); else if (button.type == "infantry" || button.type == "vehicle") sounds.play("unit_ready"), this.finishDeployingUnit(button);
                }
            }
        },
        powerOut: 0,
        powerIn: 0,
        lowPowerMode: !1,
        powerScale: 4,
        checkPower: function() {
            var offsetX = this.left, offsetY = this.top + 160, barHeight = 320, barWidth = 20;
            this.powerOut = 0, this.powerIn = 0;
            for (var k = game.buildings.length - 1; k >= 0; k--) {
                var building = game.buildings[k];
                building.powerIn && building.team == game.currentLevel.team && (this.powerIn += building.powerIn), building.powerOut && building.team == game.currentLevel.team && (this.powerOut += building.powerOut);
            }
            var red = "rgba(174,52,28,0.7)", orange = "rgba(250,100,0,0.6)", green = "rgba(84,252,84,0.3)";
            this.powerOut / this.powerIn < 1.1 ? this.powerOut / this.powerIn < 1 ? this.powerOut < this.powerIn && (context.fillStyle = red, this.lowPowerMode == 0 && sounds.play("low_power"), this.lowPowerMode = !0) : (context.fillStyle = orange, this.lowPowerMode = !1) : (context.fillStyle = green, this.lowPowerMode = !1), context.fillRect(offsetX + 8, offsetY + barHeight - this.powerOut / this.powerScale, barWidth - 14, this.powerOut / this.powerScale), context.drawImage(this.powerIndicator, offsetX, offsetY + barHeight - this.powerIn / this.powerScale);
        },
        draw: function() {
            context.drawImage(this.tabsImage, 0, this.top - this.tabsImage.height + 2), context.fillStyle = "lightgreen", context.font = '12px "Command and Conquer"';
            var c = (this.cash + "").split("").join(" ");
            context.fillText(c, 400 - c.length * 5 / 2, 31), this.checkDependency(), this.textBrightness = this.textBrightness + this.textBrightnessDelta, this.textBrightness < 0 && (this.textBrightness = 1);
            for (var i = 0; i < this.leftButtons.length; i++) this.processButton("left", i);
            for (var i = 0; i < this.rightButtons.length; i++) this.processButton("right", i);
            if (this.visible) {
                context.drawImage(this.sidebarImage, this.left, this.top), this.checkPower();
                var maxLeft = this.leftButtons.length > 6 ? 6 : this.leftButtons.length;
                for (var i = 0; i < maxLeft; i++) this.drawButton("left", i);
                var maxRight = this.rightButtons.length > 6 ? 6 : this.rightButtons.length;
                for (var i = 0; i < maxRight; i++) this.drawButton("right", i);
            }
            context.clearRect(0, game.viewportTop + game.viewportHeight, canvas.width, 30);
        }
    }, buildings = {
        types: [],
        buildingDetails: {
            "construction-yard": {
                name: "construction-yard",
                label: "Construction Yard",
                powerIn: 15,
                powerOut: 30,
                cost: 5e3,
                sight: 3,
                hitPoints: 400,
                imagesToLoad: [ {
                    name: "build",
                    count: 32
                }, {
                    name: "healthy",
                    count: 4
                }, {
                    name: "damaged",
                    count: 4
                }, {
                    name: "ultra-damaged",
                    count: 1
                }, {
                    name: "healthy-construct",
                    count: 20
                }, {
                    name: "damaged-construct",
                    count: 20
                } ],
                gridShape: [ [ 1, 1, 1 ], [ 1, 1, 1 ] ]
            },
            barracks: {
                name: "barracks",
                label: "Power Plant",
                powerIn: 20,
                cost: 300,
                sight: 3,
                hitPoints: 400,
                imagesToLoad: [ {
                    name: "build",
                    count: 20
                }, {
                    name: "healthy",
                    count: 10
                }, {
                    name: "damaged",
                    count: 10
                }, {
                    name: "ultra-damaged",
                    count: 1
                } ],
                gridShape: [ [ 1, 1 ], [ 1, 1 ] ]
            },
            "power-plant": {
                name: "power-plant",
                label: "Power Plant",
                powerOut: 100,
                cost: 300,
                sight: 2,
                hitPoints: 200,
                imagesToLoad: [ {
                    name: "build",
                    count: 20
                }, {
                    name: "healthy",
                    count: 4
                }, {
                    name: "damaged",
                    count: 4
                }, {
                    name: "ultra-damaged",
                    count: 1
                } ],
                gridShape: [ [ 1, 0 ], [ 1, 1 ] ]
            },
            "weapons-factory": {
                name: "weapons-factory",
                label: "Weapons Factory",
                powerIn: 30,
                cost: 2e3,
                sight: 2,
                hitPoints: 200,
                imagesToLoad: [ {
                    name: "build",
                    count: 20
                }, {
                    name: "healthy",
                    count: 1
                }, {
                    name: "damaged",
                    count: 1
                }, {
                    name: "ultra-damaged",
                    count: 0
                }, {
                    name: "healthy-construct",
                    count: 9
                }, {
                    name: "damaged-construct",
                    count: 9
                }, {
                    name: "healthy-base",
                    count: 1
                }, {
                    name: "damaged-base",
                    count: 1
                }, {
                    name: "ultra-damaged-base",
                    count: 1
                } ],
                gridShape: [ [ 1, 1, 1 ], [ 1, 1, 1 ], [ 1, 1, 1 ] ]
            }
        },
        preloadImage: preloadImage,
        loadImageArray: loadImageArray,
        preloadCount: 0,
        loadedCount: 0,
        draw: function() {
            context.drawImage(this.bibImage, this.x * game.gridSize + game.viewportAdjustX, (this.y + this.gridHeight - 1) * game.gridSize + game.viewportAdjustY);
            var life = this.getLife();
            this.status == "build" || this.status == "sell" ? imageCategory = "build" : this.status == "" ? imageCategory = this.life : imageCategory = this.life + "-" + this.status;
            var baseImage = this.imageArray[this.life + "-base"];
            baseImage && baseImage.length > 0 && this.status != "build" && this.status != "sell" && drawSprite(baseImage[0], game.gridSize * this.x + game.viewportAdjustX, this.y * game.gridSize + game.viewportAdjustY, this.team, this.type);
            var imageList = this.imageArray[imageCategory];
            this.animationIndex || (this.animationIndex = 0);
            if (imageList.length > Math.floor(this.animationIndex / this.animationSpeed)) {
                var image = imageList[Math.floor(this.animationIndex / this.animationSpeed)];
                this.status == "sell" && (image = imageList[imageList.length - 1 - Math.floor(this.animationIndex / this.animationSpeed)]), this.currentImage = image, drawSprite(image, this.x * game.gridSize + game.viewportAdjustX, this.y * game.gridSize + game.viewportAdjustY, this.team, this.type);
            }
            this.animationIndex++, this.animationIndex / this.animationSpeed >= imageList.length && (this.animationIndex = 0, this.status == "build" || this.status == "construct" ? this.status = "" : this.status == "sell" && (this.status = "destroy")), this.drawSelection();
        },
        load: function(name) {
            var details = this.buildingDetails[name], buildingType = {};
            buildingType.defaults = {
                type: "building",
                draw: buildings.draw,
                underPoint: underPoint,
                drawSelection: drawSelection,
                getLife: getLife,
                animationSpeed: 2,
                status: "",
                health: details.hitPoints,
                gridHeight: details.gridShape.length,
                gridWidth: details.gridShape[0].length,
                pixelHeight: details.gridShape.length * game.gridSize,
                pixelWidth: details.gridShape[0].length * game.gridSize,
                bibImage: this.preloadImage("buildings/bib/bib-" + details.gridShape[0].length + ".gif"),
                pixelOffsetX: 0,
                pixelOffsetY: 0,
                pixelTop: 0,
                pixelLeft: 0
            }, buildingType.imageArray = [];
            for (var i = details.imagesToLoad.length - 1; i >= 0; i--) {
                var constructImageCount = details.imagesToLoad[i].count, constructImageName = details.imagesToLoad[i].name;
                buildingType.imageArray[constructImageName] = this.loadImageArray("buildings/" + name + "/" + name + "-" + constructImageName, constructImageCount, ".gif");
            }
            $.extend(buildingType, details), this.types[name] = buildingType;
        },
        add: function(details) {
            var newBuilding = {};
            newBuilding.team = game.currentLevel.team;
            var name = details.name;
            return $.extend(newBuilding, this.types[name].defaults), $.extend(newBuilding, this.types[name]), $.extend(newBuilding, details), newBuilding;
        }
    }, infantry = {
        types: [],
        infantryDetails: {
            minigunner: {
                name: "minigunner",
                label: "Minigunner",
                speed: 8,
                cost: 100,
                sight: 1,
                hitPoints: 50,
                collisionRadius: 5,
                imagesToLoad: [ {
                    name: "stand",
                    count: 1,
                    directionCount: 8
                }, {
                    name: "walk",
                    count: 6,
                    directionCount: 8
                }, {
                    name: "fire",
                    count: 8,
                    directionCount: 8
                } ]
            }
        },
        preloadImage: preloadImage,
        loadImageArray: loadImageArray,
        preloadCount: 0,
        loadedCount: 0,
        collision: function(otherUnit) {
            if (this == otherUnit) return !1;
            var distanceSquared = Math.pow(this.x - otherUnit.x, 2) + Math.pow(this.y - otherUnit.y, 2), radiusSquared = Math.pow((this.collisionRadius + otherUnit.collisionRadius) / game.gridSize, 2);
            return distanceSquared <= radiusSquared;
        },
        load: function(name) {
            var details = this.infantryDetails[name], infantryType = {};
            infantryType.defaults = {
                type: "infantry",
                draw: this.draw,
                drawSelection: drawSelection,
                underPoint: underPoint,
                collision: this.collision,
                move: this.move,
                getLife: getLife,
                status: "stand",
                animationSpeed: 4,
                health: details.hitPoints,
                pixelOffsetX: -25,
                pixelOffsetY: -19.5,
                pixelWidth: 16,
                pixelHeight: 16,
                pixelTop: 6,
                pixelLeft: 16
            }, infantryType.imageArray = [];
            for (var i = details.imagesToLoad.length - 1; i >= 0; i--) {
                var constructImageCount = details.imagesToLoad[i].count, constructImageDirectionCount = details.imagesToLoad[i].directionCount, constructImageName = details.imagesToLoad[i].name, imgArray = [];
                for (var j = 0; j < constructImageDirectionCount; j++) imgArray[j] = this.loadImageArray("units/infantry/" + name + "/" + name + "-" + constructImageName + "-" + j, constructImageCount, ".gif");
                infantryType.imageArray[constructImageName] = imgArray;
            }
            $.extend(infantryType, details), this.types[name] = infantryType;
        },
        draw: function() {
            var imageList = this.imageArray[this.status][this.moveDirection];
            this.animationIndex++, this.animationIndex / this.animationSpeed >= imageList.length && (this.animationIndex = 0);
            var moveImage = imageList[Math.floor(this.animationIndex / this.animationSpeed)], x = this.x * game.gridSize + game.viewportAdjustX + this.pixelOffsetX, y = this.y * game.gridSize + game.viewportAdjustY + this.pixelOffsetY;
            drawSprite(moveImage, x, y, this.team, this.type), this.drawSelection();
        },
        add: function(details) {
            var newInfantry = {}, name = details.name;
            return newInfantry.moveDirection = 0, newInfantry.animationIndex = 0, newInfantry.team = game.currentLevel.team, $.extend(newInfantry, this.types[name].defaults), $.extend(newInfantry, this.types[name]), $.extend(newInfantry, details), newInfantry;
        },
        move: function() {
            this.speedCounter || (this.speedCounter = 0), this.speedCounter++;
            var angle = this.moveDirection / 8 * 2 * Math.PI;
            this.status == "walk" && (this.x = this.x - .005 * this.speed * Math.sin(angle), this.y = this.y - .005 * this.speed * Math.cos(angle)), this.speedCounter >= 7 && (this.speedCounter = 0, this.moveDirection = Math.floor(this.moveDirection + Math.round((Math.random() - .5) * 10) * 1 / 10), this.moveDirection > 7 ? this.moveDirection = 0 : this.moveDirection < 0 && (this.moveDirection = 7), this.status = Math.random() > .7 ? "fire" : Math.random() > .7 ? "stand" : "walk");
        }
    }, vehicles = {
        types: [],
        vehicleDetails: {
            mcv: {
                name: "mcv",
                label: "Mobile Construction Vehicle",
                turnSpeed: 5,
                speed: 12,
                cost: 5e3,
                hitPoints: 200,
                sight: 2,
                moveImageCount: 32,
                pixelWidth: 48,
                pixelHeight: 48,
                pixelOffsetX: -24,
                pixelOffsetY: -24,
                collisionRadius: 14,
                softCollisionRadius: 18
            },
            "light-tank": {
                name: "light-tank",
                label: "Light Tank",
                turnSpeed: 5,
                speed: 18,
                cost: 600,
                sight: 3,
                hitPoints: 300,
                primaryWeapon: 9,
                reloadTime: 2e3,
                moveImageCount: 32,
                turretImageCount: 32,
                pixelWidth: 24,
                pixelHeight: 24,
                pixelOffsetX: -12,
                pixelOffsetY: -12,
                collisionRadius: 8,
                softCollisionRadius: 11
            },
            jeep: {
                name: "jeep",
                label: "Hum-Vee",
                turnSpeed: 10,
                speed: 30,
                cost: 400,
                sight: 2,
                hitPoints: 150,
                primaryWeapon: 16,
                moveImageCount: 32,
                turretImageCount: 32,
                pixelWidth: 24,
                pixelHeight: 24,
                pixelOffsetX: -12,
                pixelOffsetY: -12,
                collisionRadius: 6
            }
        },
        preloadImage: preloadImage,
        loadImageArray: loadImageArray,
        preloadCount: 0,
        loadedCount: 0,
        collision: function(otherUnit) {
            if (this == otherUnit) return !1;
            var distanceSquared = Math.pow(this.x - otherUnit.x, 2) + Math.pow(this.y - otherUnit.y, 2), radiusSquared = Math.pow((this.collisionRadius + otherUnit.collisionRadius) / game.gridSize, 2), softHardRadiusSquared = Math.pow((this.softCollisionRadius + otherUnit.collisionRadius) / game.gridSize, 2), softRadiusSquared = Math.pow((this.softCollisionRadius + otherUnit.softCollisionRadius) / game.gridSize, 2);
            return distanceSquared > radiusSquared ? distanceSquared < softHardRadiusSquared ? {
                type: "soft-hard",
                distance: Math.pow(distanceSquared, .5)
            } : distanceSquared > softRadiusSquared ? !1 : {
                type: "soft",
                distance: Math.pow(distanceSquared, .5)
            } : {
                type: "hard",
                distance: Math.pow(distanceSquared, .5)
            };
        },
        load: function(name) {
            var details = this.vehicleDetails[name], vehicleType = {};
            vehicleType.defaults = {
                type: "vehicle",
                draw: this.draw,
                drawSelection: drawSelection,
                underPoint: underPoint,
                processOrders: this.processOrders,
                moveTo: this.moveTo,
                move: this.move,
                collision: this.collision,
                getLife: getLife,
                animationSpeed: 4,
                health: details.hitPoints,
                pixelLeft: 0,
                pixelTop: 0,
                pixelOffsetX: 0,
                pixelOffsetY: 0,
                moveDirection: 0,
                turretDirection: 0
            }, !details.moveImages && details.moveImageCount && (vehicleType.moveImages = this.loadImageArray("units/vehicles/" + details.name + "/" + details.name, details.moveImageCount, ".gif")), !details.turretImages && details.turretImageCount && (vehicleType.turretImages = this.loadImageArray("units/vehicles/" + details.name + "/" + details.name + "-turret", details.turretImageCount, ".gif")), $.extend(vehicleType, details), this.types[name] = vehicleType;
        },
        draw: function() {
            var moveImage = this.moveImages[Math.floor(this.moveDirection)], x = this.x * game.gridSize + this.pixelOffsetX + game.viewportAdjustX, y = this.y * game.gridSize + this.pixelOffsetY + game.viewportAdjustY;
            drawSprite(moveImage, x, y, this.team, this.name == "mcv" ? "mcv" : this.type);
            if (this.turretImageCount) {
                var turretImage = this.turretImages[Math.floor(this.turretDirection)];
                context.drawImage, drawSprite(turretImage, x, y, this.team, this.type);
            }
            this.drawSelection(), game.debugMode && (context.beginPath(), context.arc(this.x * game.gridSize + game.viewportAdjustX, this.y * game.gridSize + game.viewportAdjustY, this.collisionRadius, 0, Math.PI * 2), context.stroke());
        },
        movementSpeed: 0,
        moveTo: function(destination, turretAtTarget) {
            var start = [ Math.floor(this.x), Math.floor(this.y) ], end = [ destination.x, destination.y ];
            this.path = findPath(start, end), this.instructions = [];
            if (this.path.length > 1) {
                var newAngle = findAngle(this.path[1], this.path[0], 32), movement = this.movementSpeed * game.speedAdjustmentFactor / game.gridSize, angleRadians = this.moveDirection / 32 * 2 * Math.PI;
                this.x = this.x - movement * Math.sin(angleRadians), this.y = this.y - movement * Math.cos(angleRadians), this.colliding = !1;
                var collision;
                for (var k = game.units.length - 1; k >= 0; k--) (collision = this.collision(game.units[k])) && collision.distance < this.collisionDistance && (this.collisionType = collision.type, this.collisionDistance = collision.distance, this.collisionWith = game.units[k], this.colliding = !0);
                for (var k = 0; k < game.obstructionGrid.length; k++) for (var l = 0; l < game.obstructionGrid[k].length; l++) if (game.obstructionGrid[k][l] > 0) {
                    var tile = {
                        x: l + .5,
                        y: k + .5,
                        collisionRadius: game.gridSize * .5,
                        softCollisionRadius: game.gridSize * .7
                    };
                    (collision = this.collision(tile)) && collision.distance < this.collisionDistance && (this.collisionType = collision.type, this.collisionDistance = collision.distance, this.collisionWith = tile, this.colliding = !0);
                }
                this.x = this.x + movement * Math.sin(angleRadians), this.y = this.y + movement * Math.cos(angleRadians);
                if (this.colliding) {
                    var collDirection = findAngle(this.collisionWith, this, 32), dTurn = angleDiff(this.moveDirection, collDirection, 32), dTurnDestination = angleDiff(newAngle, collDirection, 32);
                    switch (this.collisionType) {
                      case "hard":
                        this.movementSpeed = 0, Math.abs(dTurn) == 0 ? (Math.abs(dTurnDestination) > 0 ? newAngle = addAngle(this.moveDirection, -1 * dTurnDestination / Math.abs(dTurnDestination), 32) : newAngle = addAngle(this.moveDirection, -1, 32), this.moveDirection = newAngle) : Math.abs(dTurn) > 2 ? Math.abs(dTurn) < 4 ? (newAngle = addAngle(this.moveDirection, -1 * dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle) : Math.abs(dTurn) < 9 ? (newAngle = addAngle(this.moveDirection, -dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle) : this.movementSpeed = this.speed : (newAngle = addAngle(this.moveDirection, -1 * dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle);
                        break;
                      case "soft-hard":
                        Math.abs(dTurn) == 0 ? (this.movementSpeed = 0, Math.abs(dTurnDestination) > 0 ? newAngle = addAngle(this.moveDirection, -1 * dTurnDestination / Math.abs(dTurnDestination), 32) : newAngle = addAngle(this.moveDirection, -1, 32), this.moveDirection = newAngle) : Math.abs(dTurn) > 2 ? Math.abs(dTurn) < 4 ? (this.movementSpeed = 0, newAngle = addAngle(this.moveDirection, -1 * dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle) : Math.abs(dTurn) < 9 ? (this.movementSpeed = 0, newAngle = addAngle(this.moveDirection, -1 * dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle) : this.movementSpeed = this.speed : (this.movementSpeed = 0, newAngle = addAngle(this.moveDirection, -1 * dTurn / Math.abs(dTurn), 32), this.moveDirection = newAngle);
                        break;
                      case "soft":
                        Math.abs(dTurn) == 0 ? (this.movementSpeed = this.speed * (this.collisionDistance - this.collisionRadius) / (this.softCollisionRadius - this.collisionRadius), this.movementSpeed < 0 && (this.movementSpeed = 0), Math.abs(dTurnDestination) > 0 ? newAngle = addAngle(this.moveDirection, -1 * dTurnDestination / Math.abs(dTurnDestination), 32) : newAngle = addAngle(this.moveDirection, -1, 32)) : Math.abs(dTurn) > 2 ? Math.abs(dTurn) < 4 ? (this.movementSpeed = this.speed * (this.collisionDistance - this.collisionRadius) / (this.softCollisionRadius - this.collisionRadius), this.movementSpeed < 0 && (this.movementSpeed = 0), newAngle = addAngle(this.moveDirection, -dTurn * 1, 32)) : Math.abs(dTurn) < 9 ? (this.movementSpeed = this.speed, newAngle = addAngle(this.moveDirection, -dTurn * 1, 32)) : this.movementSpeed = this.speed : (this.movementSpeed = this.speed * (this.collisionDistance - this.collisionRadius) / (this.softCollisionRadius - this.collisionRadius), this.movementSpeed < 0 && (this.movementSpeed = 0), newAngle = addAngle(this.moveDirection, -dTurn * 1, 32));
                    }
                } else this.movementSpeed = this.speed;
                this.movementSpeed > this.speed ? this.movementSpeed = this.speed : this.movementSpeed < -this.speed && (this.movementSpeed = -this.speed), this.moveDirection != newAngle && this.instructions.push({
                    type: "turn",
                    toDirection: newAngle
                });
                var magTurn = Math.abs(angleDiff(this.moveDirection, newAngle, 32));
                (magTurn < 8 || this.colliding) && this.instructions.push({
                    type: "move",
                    distance: 1
                });
                var turretAngle;
                turretAtTarget ? turretAngle = findAngle(destination, this, 32) : turretAngle = findAngle(this.path[1], this.path[0], 32), this.turretDirection != turretAngle && this.instructions.push({
                    type: "aim",
                    toDirection: turretAngle
                });
            }
        },
        processOrders: function() {
            this.colliding = !1, this.collisionType = "", this.collisionDistance = this.softCollisionRadius + 1, this.collisionWith = null, this.movementSpeed = 0, this.instructions = [], this.orders || (this.orders = {
                type: "guard"
            });
            if (this.orders.type == "make-way") Math.abs(collDirection) > 16 ? this.instructions.push({
                type: "move",
                distance: .25
            }) : this.instructions.push({
                type: "move",
                distance: -.25
            }), this.movementSpeed = this.speed, this.orders = {
                type: "guard"
            }; else if (this.orders.type == "move") {
                this.moveTo(this.orders.to);
                if (this.path.length <= 1 || this.colliding && this.collisionType == "soft" && this.path.length <= 2 || this.colliding && this.collisionType == "soft-hard" && this.path.length <= 2 || this.colliding && this.collisionType == "hard" && this.path.length <= 2) this.orders = {
                    type: "guard"
                };
            } else if (this.orders.type == "patrol") {
                var enemiesInRange = findEnemiesInRange(this);
                if (enemiesInRange.length > 0) {
                    var enemy = enemiesInRange[0];
                    this.orders = {
                        type: "attack",
                        target: enemy
                    };
                    return;
                }
                this.moveTo(this.orders.to), this.path.length <= 1 && (this.orders = {
                    type: "patrol",
                    to: this.orders.from,
                    from: this.orders.to
                });
            } else if (this.orders.type == "protect" || this.orders.type == "attack") {
                if (this.orders.target.status == "destroy") {
                    this.orders = {
                        type: "guard"
                    };
                    return;
                }
                var targetX = this.orders.target.x, targetY = this.orders.target.y;
                this.orders.target.type == "turret" && (targetX += this.orders.target.pixelWidth / (2 * game.gridSize), targetY += this.orders.target.pixelHeight / (2 * game.gridSize)), this.orders.target.type == "building" && (targetX += this.orders.target.gridWidth / 2, targetY += this.orders.target.gridHeight);
                if (Math.pow(targetX - this.x, 2) + Math.pow(targetY - this.y, 2) > Math.pow(this.sight, 2)) this.moveTo({
                    x: Math.floor(targetX),
                    y: Math.floor(targetY)
                }, !0); else if (this.orders.type == "attack") {
                    var turretAngle = findAngle({
                        x: targetX,
                        y: targetY
                    }, this, 32);
                    this.turretDirection == turretAngle ? this.instructions.push({
                        type: "fire"
                    }) : (this.instructions.push({
                        type: "aim",
                        toDirection: turretAngle
                    }), console.log("turret " + this.turretDirection + "  -> " + turretAngle));
                }
            } else if (this.orders.type == "build") this.moveDirection != 15 ? this.instructions.push({
                type: "turn",
                toDirection: 15
            }) : (this.status = "destroy", sounds.play("construction"), game.buildings.push(buildings.add({
                name: "construction-yard",
                x: Math.floor(this.x) - 1,
                y: Math.floor(this.y) - 1,
                status: "build"
            }))); else if (this.orders.type == "guard") {
                var enemiesInRange = findEnemiesInRange(this);
                if (enemiesInRange.length > 0) {
                    var enemy = enemiesInRange[0];
                    this.orders = {
                        type: "attack",
                        target: enemy
                    };
                }
            }
        },
        move: function() {
            this.moving = !1, this.attacking = !1, this.instructions || (this.instructions = []);
            if (this.instructions.length == 0) return;
            for (var i = 0; i < this.instructions.length; i++) {
                var instr = this.instructions[i];
                instr.type == "turn" && (instr.toDirection == this.moveDirection && (instr.type = "done"), instr.toDirection > this.moveDirection && instr.toDirection - this.moveDirection < 16 || instr.toDirection < this.moveDirection && this.moveDirection - instr.toDirection > 16 ? (this.moveDirection = this.moveDirection + this.turnSpeed * .1, (this.moveDirection - instr.toDirection) * (this.moveDirection + this.turnSpeed * .1 - instr.toDirection) <= 0 && (this.moveDirection = instr.toDirection)) : (this.moveDirection = this.moveDirection - this.turnSpeed * .1, (this.moveDirection - instr.toDirection) * (this.moveDirection - this.turnSpeed * .1 - instr.toDirection) <= 0 && (this.moveDirection = instr.toDirection)), this.moveDirection > 31 ? this.moveDirection = 0 : this.moveDirection < 0 && (this.moveDirection = 31));
                if (instr.type == "move") {
                    if (instr.distance <= 0) {
                        instr.type = "done";
                        return;
                    }
                    this.moving = !0;
                    var movement = this.movementSpeed * game.speedAdjustmentFactor / game.gridSize;
                    instr.distance -= movement;
                    var angle = this.moveDirection / 32 * 2 * Math.PI;
                    this.x = this.x - movement * Math.sin(angle), this.y = this.y - movement * Math.cos(angle);
                }
                if (instr.type == "aim") if (instr.toDirection == this.turretDirection) instr.type = "done"; else {
                    var delta = angleDiff(Math.floor(this.turretDirection), Math.floor(instr.toDirection), 32);
                    Math.abs(delta) < 1 ? (this.turretDirection = instr.toDirection, instr.type = "done") : this.turretDirection = addAngle(this.turretDirection, delta / Math.abs(delta), 32);
                }
                if (instr.type == "fire" && !this.bulletFiring) {
                    sounds.play("tank_fire"), this.bulletFiring = !0;
                    var angle = this.turretDirection / 32 * 2 * Math.PI;
                    game.fireBullet({
                        x: this.x,
                        y: this.y,
                        angle: angle,
                        range: this.sight,
                        source: this
                    });
                }
            }
        },
        add: function(details) {
            var newVehicle = {}, name = details.name;
            return newVehicle.team = game.currentLevel.team, $.extend(newVehicle, this.types[name].defaults), $.extend(newVehicle, this.types[name]), $.extend(newVehicle, details), newVehicle;
        }
    }, turrets = {
        types: [],
        turretDetails: {
            "gun-turret": {
                name: "gun-turret",
                label: "Gun Turret",
                powerIn: 20,
                primaryWeapon: 12,
                cost: 600,
                hitPoints: 200,
                sight: 5,
                turnSpeed: 5,
                reloadTime: 1500,
                pixelWidth: 24,
                pixelHeight: 24,
                buildImageCount: 20,
                turretImageCount: 32,
                pixelOffsetX: -12,
                pixelOffsetY: -12,
                pixelTop: 12,
                pixelLeft: 12
            }
        },
        preloadImage: preloadImage,
        loadImageArray: loadImageArray,
        preloadCount: 0,
        loadedCount: 0,
        load: function(name) {
            var details = this.turretDetails[name], turretType = {};
            turretType.defaults = {
                type: "turret",
                status: "",
                draw: this.draw,
                drawSelection: drawSelection,
                processOrders: this.processOrders,
                underPoint: underPoint,
                move: this.move,
                getLife: getLife,
                animationSpeed: 4,
                health: details.hitPoints,
                pixelLeft: 0,
                pixelTop: 0,
                pixelOffsetX: 0,
                pixelOffsetY: 0,
                turretDirection: 0
            }, turretType.imageArray = [], turretType.imageArray.build = this.loadImageArray("turrets/" + details.name + "/" + details.name + "-build", details.buildImageCount, ".gif"), turretType.imageArray.healthy = this.loadImageArray("turrets/" + details.name + "/" + details.name + "-healthy", details.turretImageCount, ".gif"), turretType.imageArray.damaged = this.loadImageArray("turrets/" + details.name + "/" + details.name + "-damaged", details.turretImageCount, ".gif"), $.extend(turretType, details), this.types[name] = turretType;
        },
        draw: function() {
            var life = this.getLife();
            this.status == "build" || this.status == "sell" ? imageCategory = "build" : this.status == "" && (imageCategory = this.life, this.life == "ultra-damaged" && (imageCategory = "damaged"));
            var imageList = this.imageArray[imageCategory];
            this.animationIndex || (this.animationIndex = 0);
            if (this.status == "") {
                var image = imageList[Math.floor(this.turretDirection)];
                drawSprite(image, this.x * game.gridSize + game.viewportAdjustX, this.y * game.gridSize + game.viewportAdjustY, this.team, this.type);
            } else {
                if (imageList.length > Math.floor(this.animationIndex / this.animationSpeed)) {
                    var image = imageList[Math.floor(this.animationIndex / this.animationSpeed)];
                    this.status == "sell" && (image = imageList[imageList.length - 1 - Math.floor(this.animationIndex / this.animationSpeed)]), this.currentImage = image, drawSprite(image, this.x * game.gridSize + game.viewportAdjustX, this.y * game.gridSize + game.viewportAdjustY, this.team, this.type);
                }
                this.animationIndex++, this.animationIndex / this.animationSpeed >= imageList.length && (this.animationIndex = 0, this.status == "build" || this.status == "construct" ? this.status = "" : this.status == "sell" && this.status == "destroy");
            }
            this.drawSelection();
        },
        processOrders: function() {
            this.orders || (this.orders = {
                type: "guard"
            });
            if (this.orders.type == "attack") {
                this.instructions = [];
                if (this.orders.target.status == "destroy") {
                    this.orders = {
                        type: "guard"
                    };
                    return;
                }
                var start = [ Math.floor(this.x), Math.floor(this.y) ], targetX = this.orders.target.x, targetY = this.orders.target.y;
                this.orders.target.type == "turret" && (targetX += this.orders.target.pixelWidth / (2 * game.gridSize), targetY += this.orders.target.pixelHeight / (2 * game.gridSize)), this.orders.target.type == "building" && (targetX += this.orders.target.gridWidth / 2, targetY += this.orders.target.gridHeight);
                if (Math.pow(targetX - this.x, 2) + Math.pow(targetY - this.y, 2) < Math.pow(this.sight, 2)) {
                    if (this.orders.type == "attack") {
                        var turretAngle = findAngle({
                            x: targetX,
                            y: targetY
                        }, this, 32);
                        this.turretDirection != turretAngle ? this.instructions.push({
                            type: "aim",
                            toDirection: turretAngle
                        }) : this.instructions.push({
                            type: "fire"
                        });
                    }
                } else this.orders = {
                    type: "guard"
                };
            } else if (this.orders.type == "guard") {
                var enemiesInRange = findEnemiesInRange(this);
                if (enemiesInRange.length > 0) {
                    var enemy = enemiesInRange[0];
                    this.orders = {
                        type: "attack",
                        target: enemy
                    };
                }
            }
        },
        move: function() {
            this.instructions || (this.instructions = []);
            if (this.instructions.length == 0) return;
            for (var i = 0; i < this.instructions.length; i++) {
                var instr = this.instructions[i];
                instr.type == "aim" && (instr.toDirection == this.turretDirection && (instr.type = "done"), instr.toDirection > this.turretDirection && instr.toDirection - this.turretDirection < 16 || instr.toDirection < this.turretDirection && this.turretDirection - instr.toDirection > 16 ? (this.turretDirection = this.turretDirection + this.turnSpeed * .1, (this.turretDirection - instr.toDirection) * (this.turretDirection + this.turnSpeed * .1 - instr.toDirection) <= 0 && (this.turretDirection = instr.toDirection)) : (this.turretDirection = this.turretDirection - this.turnSpeed * .1, (this.turretDirection - instr.toDirection) * (this.turretDirection - this.turnSpeed * .1 - instr.toDirection) <= 0 && (this.turretDirection = instr.toDirection)), this.turretDirection > 31 ? this.turretDirection = 0 : this.turretDirection < 0 && (this.turretDirection = 31));
                if (instr.type == "fire" && !this.bulletFiring) {
                    sounds.play("tank_fire"), this.bulletFiring = !0;
                    var angle = this.turretDirection / 32 * 2 * Math.PI;
                    game.fireBullet({
                        x: this.x + .5,
                        y: this.y + .5,
                        angle: angle,
                        range: this.sight,
                        source: this,
                        damage: 10
                    });
                }
            }
        },
        add: function(details) {
            var newTurret = {}, name = details.name;
            return newTurret.team = game.currentLevel.team, $.extend(newTurret, this.types[name].defaults), $.extend(newTurret, this.types[name]), $.extend(newTurret, details), newTurret;
        }
    }, ships = {
        types: [],
        load: function(name) {
            var shipType = {
                name: name
            };
        },
        add: function(newShip) {
            $.extend(newShip, this.types[name]);
        }
    }, overlay = {
        types: [],
        overlayDetails: {
            tiberium: {
                name: "tiberium",
                count: 2,
                stageCount: 12,
                gridOffsetX: 0,
                gridOffsetY: 0
            },
            tree: {
                name: "tree",
                count: 1,
                stageCount: 10,
                gridOffsetX: 0,
                gridOffsetY: -1
            },
            trees: {
                name: "trees",
                count: 1,
                stageCount: 10,
                gridOffsetX: 0,
                gridOffsetY: -1
            }
        },
        load: function(name) {
            var overlayType = {
                name: name,
                draw: this.draw
            }, details = this.overlayDetails[name], imageArray = [];
            for (i = 0; i < details.count; i++) imageArray[i] = this.loadImageArray("tiles/temperate/" + name + "/" + name + "-" + i, details.stageCount, ".gif");
            overlayType.imageArray = imageArray, $.extend(overlayType, details), this.types[name] = overlayType;
        },
        draw: function() {
            var image = this.imageArray[this.type][this.stage], x = (this.x + this.gridOffsetX) * game.gridSize + game.viewportAdjustX, y = (this.y + this.gridOffsetY) * game.gridSize + game.viewportAdjustY;
            drawSprite(image, x, y);
        },
        loadAll: function() {
            this.load("tiberium"), this.load("tree"), this.load("trees");
        },
        add: function(details) {
            var newOverlay = {
                type: 0,
                stage: 0
            }, name = details.name;
            return $.extend(newOverlay, this.types[name]), $.extend(newOverlay, details), newOverlay;
        },
        loaded: !0,
        preloadCount: 0,
        loadedCount: 0,
        preloadImage: preloadImage,
        loadImageArray: loadImageArray
    }, levels = {
        levelDetails: {
            gdi1: {
                mapUrl: "maps/gdi/map01.jpeg",
                startingCash: 4e3,
                terrain: [ {
                    x1: 0,
                    y1: 27,
                    x2: 30,
                    y2: 30,
                    type: "water"
                }, {
                    x1: 0,
                    y1: 26,
                    x2: 6,
                    y2: 26,
                    type: "water"
                }, {
                    x1: 0,
                    y1: 25,
                    x2: 5,
                    y2: 25,
                    type: "water"
                }, {
                    x1: 0,
                    y1: 24,
                    x2: 4,
                    y2: 24,
                    type: "water"
                }, {
                    x1: 29,
                    y1: 17,
                    x2: 30,
                    y2: 22,
                    type: "mountain"
                }, {
                    x1: 7,
                    y1: 6,
                    x2: 8,
                    y2: 9,
                    type: "mountain"
                }, {
                    x1: 8,
                    y1: 10,
                    x2: 9,
                    y2: 11,
                    type: "mountain"
                }, {
                    x1: 9,
                    y1: 11,
                    x2: 10,
                    y2: 15,
                    type: "mountain"
                }, {
                    x1: 10,
                    y1: 15,
                    x2: 11,
                    y2: 19,
                    type: "mountain"
                }, {
                    x1: 11,
                    y1: 19,
                    x2: 12,
                    y2: 21,
                    type: "mountain"
                }, {
                    x1: 12,
                    y1: 21,
                    x2: 14,
                    y2: 23,
                    type: "mountain"
                }, {
                    x1: 12,
                    y1: 24,
                    x2: 13,
                    y2: 24,
                    type: "mountain"
                }, {
                    x1: 14,
                    y1: 21,
                    x2: 17,
                    y2: 22,
                    type: "mountain"
                }, {
                    x1: 16,
                    y1: 23,
                    x2: 16,
                    y2: 23,
                    type: "mountain"
                } ],
                overlay: [ {
                    x: 10,
                    y: 10,
                    name: "tree"
                }, {
                    x: 16,
                    y: 3,
                    name: "tree"
                }, {
                    x: 14,
                    y: 2,
                    name: "trees"
                }, {
                    x: 9,
                    y: 2,
                    name: "trees"
                }, {
                    x: 19,
                    y: 12,
                    name: "trees"
                }, {
                    x: 15,
                    y: 13,
                    name: "trees"
                }, {
                    x: 0,
                    y: 1,
                    name: "trees"
                }, {
                    x: 2,
                    y: 1,
                    name: "trees"
                }, {
                    x: 4,
                    y: 1,
                    name: "trees"
                }, {
                    x: 8,
                    y: 1,
                    name: "tree"
                }, {
                    x: 6,
                    y: 0,
                    name: "tree"
                }, {
                    x: 7,
                    y: 0,
                    name: "tree"
                }, {
                    x: 12,
                    y: 15,
                    name: "tiberium",
                    stage: 11
                }, {
                    x: 13,
                    y: 15,
                    name: "tiberium",
                    stage: 8
                }, {
                    x: 13,
                    y: 16,
                    name: "tiberium",
                    stage: 6
                } ],
                gridWidth: 32,
                gridHeight: 32,
                team: "gdi",
                briefing: "This is a warning \n for all of you \n Kill enemy troops and have some fun",
                items: {
                    infantry: [ "minigunner" ],
                    buildings: [ "construction-yard", "barracks", "power-plant", "weapons-factory" ],
                    vehicles: [ "mcv", "light-tank" ],
                    ships: [ "bigboat" ],
                    turrets: [ "gun-turret" ]
                },
                scriptedEvents: [ {
                    id: "trigger1",
                    description: "Initial four reinforcement troops land on beach",
                    actions: [ {
                        action: "wait",
                        tigger: "time",
                        time: 100
                    }, {
                        action: "sound",
                        sound: "reinforcements_have_arrived"
                    }, {
                        action: "addUnit",
                        unit: {
                            name: "hovercraft",
                            type: "vehicle",
                            unselectable: !0,
                            id: "hovercraft1",
                            x: 30,
                            y: 30,
                            direction: "up",
                            carrying: [ {
                                name: "gunner"
                            } ]
                        }
                    }, {
                        action: "move",
                        id: "hovercraft1",
                        x: 30,
                        y: 27
                    }, {
                        action: "unload",
                        id: "hovercraft1",
                        x: 30,
                        y: 28
                    }, {
                        action: "move",
                        id: "hovercraft1",
                        x: 30,
                        y: 30
                    }, {
                        action: "removeUnit",
                        id: "hovercraft1"
                    } ]
                }, {
                    id: "trigger2",
                    description: "Blow up enemy powerplant when the time comes",
                    actions: [ {
                        action: "wait",
                        trigger: "condition",
                        condition: function() {
                            return !0;
                        }
                    }, {
                        action: "sound",
                        sound: "low_power"
                    }, {
                        action: "destroyBuilding",
                        id: "powerplant1"
                    } ]
                }, {
                    id: "wintrigger",
                    actions: [ {
                        action: "wait",
                        trigger: "condition",
                        condition: function() {
                            return units.enemyUnitCount() == 0 && buildings.enemyBuildingsCount == 0;
                        }
                    }, {
                        action: "endLevel",
                        type: "success"
                    } ]
                } ]
            }
        },
        preloadImage: preloadImage,
        loaded: !0,
        preloadCount: 0,
        loadedCount: 0,
        load: function(id) {
            var level = {};
            level.id = id, level.mapImage = this.preloadImage(this.levelDetails[id].mapUrl);
            var details = this.levelDetails[id];
            for (item in details.items) {
                if (item == "vehicles") for (var i = details.items[item].length - 1; i >= 0; i--) vehicles.load(this.levelDetails[id].items[item][i]);
                if (item == "buildings") for (var i = details.items[item].length - 1; i >= 0; i--) buildings.load(details.items[item][i]);
                if (item == "infantry") for (var i = details.items[item].length - 1; i >= 0; i--) infantry.load(details.items[item][i]);
                if (item == "turrets") for (var i = details.items[item].length - 1; i >= 0; i--) turrets.load(details.items[item][i]);
            }
            var obstructionGrid = new Array, mapGrid = new Array;
            for (var y = 0; y < details.gridHeight; y++) {
                obstructionGrid[y] = new Array, mapGrid[y] = new Array;
                for (var x = 0; x < details.gridWidth; x++) obstructionGrid[y][x] = 0;
            }
            for (var i = details.terrain.length - 1; i >= 0; i--) {
                var terrain = details.terrain[i];
                for (var x = terrain.x1; x <= terrain.x2; x++) for (var y = terrain.y1; y <= terrain.y2; y++) obstructionGrid[y][x] = 1, mapGrid[y][x] = terrain.type;
            }
            var overlayArray = [];
            for (var i = details.overlay.length - 1; i >= 0; i--) overlayArray.push(overlay.add(details.overlay[i]));
            return level.mapGrid = mapGrid, level.obstructionGrid = obstructionGrid, level.overlay = overlayArray, sidebar.cash = details.startingCash, level;
        }
    }, sounds = {
        sound_list: [],
        loaded: !0,
        load: function(name, path) {
            var sound = new Audio("audio/" + path + "/" + name + ".ogg");
            return sound.load(), sound;
        },
        play: function(name, unique) {
            var options = this.sound_list[name];
            if (options.length == 1) options[0].play(); else {
                var i = Math.floor(options.length * Math.random());
                options[i].play();
            }
        },
        loadAll: function() {
            this.sound_list.building_in_progress = [ this.load("building_in_progress", "voice") ], this.sound_list.insufficient_funds = [ this.load("insufficient_funds", "voice") ], this.sound_list.building = [ this.load("building", "voice") ], this.sound_list.on_hold = [ this.load("on_hold", "voice") ], this.sound_list.cancelled = [ this.load("cancelled", "voice") ], this.sound_list.cannot_deploy_here = [ this.load("cannot_deploy_here", "voice") ], this.sound_list.new_construction_options = [ this.load("new_construction_options", "voice") ], this.sound_list.construction_complete = [ this.load("construction_complete", "voice") ], this.sound_list.not_ready = [ this.load("not_ready", "voice") ], this.sound_list.reinforcements_have_arrived = [ this.load("reinforcements_have_arrived", "voice") ], this.sound_list.low_power = [ this.load("low_power", "voice") ], this.sound_list.unit_ready = [ this.load("unit_ready", "voice") ], this.sound_list.mission_accomplished = [ this.load("mission_accomplished", "voice") ], this.sound_list.mission_failure = [ this.load("mission_failure", "voice") ], this.sound_list.construction = [ this.load("construction", "sounds") ], this.sound_list.crumble = [ this.load("crumble", "sounds") ], this.sound_list.sell = [ this.load("sell", "sounds") ], this.sound_list.button = [ this.load("button", "sounds") ], this.sound_list.clock = [ this.load("clock", "sounds") ], this.sound_list.machine_gun = [ this.load("machine_gun-0", "sounds"), this.load("machine_gun-1", "sounds") ], this.sound_list.tank_fire = [ this.load("tank-fire-0", "sounds"), this.load("tank-fire-1", "sounds"), this.load("tank-fire-2", "sounds"), this.load("tank-fire-3", "sounds") ], this.sound_list.vehicle_select = [ this.load("ready_and_waiting", "talk"), this.load("vehicle_reporting", "talk"), this.load("awaiting_orders", "talk") ], this.sound_list.vehicle_move = [ this.load("affirmative", "talk"), this.load("moving_out", "talk"), this.load("acknowledged", "talk"), this.load("over_and_out", "talk") ], this.sound_list.infantry_select = [ this.load("reporting", "talk"), this.load("unit_reporting", "talk"), this.load("awaiting_orders", "talk") ], this.sound_list.infantry_move = [ this.load("affirmative", "talk"), this.load("yes_sir", "talk"), this.load("acknowledged", "talk"), this.load("right_away", "talk") ];
        }
    };
    function preloadImage(imgUrl) {
        var loadee = this;
        this.loaded = !1;
        var image = new Image;
        return image.src = "images/" + imgUrl, this.preloadCount++, $(image).bind("load", function() {
            loadee.loadedCount++, loadee.loadedCount == loadee.preloadCount && (loadee.loaded = !0);
        }), image;
    }
    function loadImageArray(imgName, count, extn) {
        extn || (extn = ".png");
        var imageArray = [];
        for (var i = 0; i < count; i++) imageArray.push(this.preloadImage(imgName + "-" + i + extn));
        return imageArray;
    }
    function getLife() {
        var life = this.health / this.hitPoints;
        life > .7 ? this.life = "healthy" : life > .4 ? this.life = "damaged" : this.life = "ultra-damaged";
    }
    function drawSelection() {
        if (this.selected) {
            context.strokeStyle = "white";
            var selectBarSize = 5, x = this.x * game.gridSize + game.viewportAdjustX + this.pixelOffsetX, y = this.y * game.gridSize + game.viewportAdjustY + this.pixelOffsetY, x1 = x + this.pixelLeft, y1 = y + this.pixelTop, x2 = x1 + this.pixelWidth, y2 = y1 + this.pixelHeight;
            context.beginPath(), context.moveTo(x1, y1 + selectBarSize), context.lineTo(x1, y1), context.lineTo(x1 + selectBarSize, y1), context.moveTo(x2 - selectBarSize, y1), context.lineTo(x2, y1), context.lineTo(x2, y1 + selectBarSize), context.moveTo(x2, y2 - selectBarSize), context.lineTo(x2, y2), context.lineTo(x2 - selectBarSize, y2), context.moveTo(x1 + selectBarSize, y2), context.lineTo(x1, y2), context.lineTo(x1, y2 - selectBarSize), context.stroke(), this.getLife(), context.beginPath(), context.rect(x1, y1 - selectBarSize - 2, this.pixelWidth * this.health / this.hitPoints, selectBarSize), this.life == "healthy" ? context.fillStyle = "lightgreen" : this.life == "damaged" ? context.fillStyle = "yellow" : context.fillStyle = "red", context.fill(), context.beginPath(), context.strokeStyle = "black", context.rect(x1, y1 - selectBarSize - 2, this.pixelWidth, selectBarSize), context.stroke(), this.primaryBuilding && context.drawImage(sidebar.primaryBuildingImage, (x1 + x2 - sidebar.primaryBuildingImage.width) / 2, y2 - sidebar.primaryBuildingImage.height);
        }
    }
    function underPoint(x, y) {
        var xo = this.x * game.gridSize + this.pixelOffsetX, yo = this.y * game.gridSize + this.pixelOffsetY, x1 = xo + this.pixelLeft, y1 = yo + this.pixelTop, x2 = x1 + this.pixelWidth, y2 = y1 + this.pixelHeight;
        return x < x1 || x > x2 || y < y1 || y > y2 ? !1 : !0;
    }
    function findEnemiesInRange(hero) {
        var enemies = [];
        hero || (hero = this);
        for (var i = game.units.length - 1; i >= 0; i--) {
            var test = game.units[i];
            test.team != hero.team && Math.pow(test.x - hero.x, 2) + Math.pow(test.y - hero.y, 2) <= Math.pow(hero.sight, 2) && enemies.push(test);
        }
        for (var i = game.buildings.length - 1; i >= 0; i--) {
            var test = game.buildings[i];
            test.team != hero.team && Math.pow(test.x + test.gridWidth / 2 - hero.x, 2) + Math.pow(test.y + test.gridHeight / 2 - hero.y, 2) <= Math.pow(hero.sight, 2) && enemies.push(test);
        }
        for (var i = game.turrets.length - 1; i >= 0; i--) {
            var test = game.turrets[i];
            test.team != hero.team && Math.pow(test.x + test.gridWidth / 2 - hero.x, 2) + Math.pow(test.y + test.gridHeight / 2 - hero.y, 2) <= Math.pow(hero.sight, 2) && enemies.push(test);
        }
        return enemies;
    }
    function findPath(start, end) {
        var g = game.obstructionGrid;
        g[end[1]][end[0]] = 0;
        var path = AStar(g, start, end, "Euclidean");
        if (path.length > 1 && game.debugMode) for (k = 0; k < path.length; k++) context.beginPath(), context.fillStyle = "rgba(150,50,100,0.5)", context.arc((path[k].x + .5) * game.gridSize + game.viewportAdjustX, (path[k].y + .5) * game.gridSize + game.viewportAdjustY, 5, 0, 2 * Math.PI), context.fill();
        return path;
    }
    var fog = {
        fogCanvas: document.createElement("canvas"),
        canvasWidth: 128,
        canvasHeight: 128,
        init: function() {
            this.fogContext = this.fogCanvas.getContext("2d"), this.fogContext.fillStyle = "rgba(0,0,0,1)", this.fogContext.fillRect(0, 0, this.canvasWidth, this.canvasHeight);
        },
        draw: function() {
            var fogCanvas = this.fogCanvas, fogContext = this.fogContext, currentMap = game.currentLevel.mapImage;
            fogContext.save(), fogContext.scale(this.canvasWidth / currentMap.width, this.canvasHeight / currentMap.height), fogContext.fillStyle = "rgba(200,200,200,1)";
            for (var i = game.units.length - 1; i >= 0; i--) {
                var unit = game.units[i];
                if (unit.team == game.currentLevel.team || unit.bulletFiring) fogContext.beginPath(), fogContext.globalCompositeOperation = "destination-out", fogContext.arc((Math.floor(unit.x) + .5) * game.gridSize, (Math.floor(unit.y) + .5) * game.gridSize, (unit.sight + .5) * game.gridSize, 0, 2 * Math.PI, !1), fogContext.fill();
            }
            for (var i = game.buildings.length - 1; i >= 0; i--) {
                var build = game.buildings[i];
                build.team == game.currentLevel.team && (fogContext.beginPath(), fogContext.globalCompositeOperation = "destination-out", fogContext.arc(Math.floor(build.x) * game.gridSize + build.pixelWidth / 2, Math.floor(build.y) * game.gridSize + build.pixelHeight / 2, build.sight * game.gridSize, 0, 2 * Math.PI, !1), fogContext.fill());
            }
            for (var i = game.turrets.length - 1; i >= 0; i--) {
                var turret = game.turrets[i];
                if (turret.team == game.currentLevel.team || turret.bulletFiring) fogContext.beginPath(), fogContext.globalCompositeOperation = "destination-out", fogContext.arc(Math.floor(turret.x) * game.gridSize + turret.pixelWidth / 2, Math.floor(turret.y) * game.gridSize + turret.pixelHeight / 2, turret.sight * game.gridSize, 0, 2 * Math.PI, !1), fogContext.fill();
            }
            fogContext.restore(), context.drawImage(this.fogCanvas, 0 + game.viewportX * this.canvasWidth / currentMap.width, 0 + game.viewportY * this.canvasHeight / currentMap.height, game.viewportWidth * this.canvasWidth / currentMap.width, game.viewportHeight * this.canvasHeight / currentMap.height, game.viewportLeft, game.viewportTop, game.viewportWidth, game.viewportHeight);
        }
    }, spriteCanvas = document.createElement("canvas"), spriteContext = spriteCanvas.getContext("2d");
    function drawSprite(image, x, y, team, type) {
        var width = image.width, height = image.height;
        spriteContext.clearRect(0, 0, width + 1, height + 1), spriteContext.drawImage(image, 0, 0);
        var imgData = spriteContext.getImageData(0, 0, width, height), size = imgData.data.length / 4;
        for (var p = 0; p < size; p++) {
            var r = imgData.data[p * 4], g = imgData.data[p * 4 + 1], b = imgData.data[p * 4 + 2], a = imgData.data[p * 4 + 2];
            if (team == "nod") {
                var colorMap = [];
                if (type == "turret" || type == "building" || type == "mcv" || type == "harvester") colorMap = [ {
                    gdi: [ 198, 170, 93 ],
                    nod: [ 218, 0, 0 ]
                }, {
                    gdi: [ 178, 149, 80 ],
                    nod: [ 191, 26, 7 ]
                }, {
                    gdi: [ 97, 76, 36 ],
                    nod: [ 108, 0, 0 ]
                }, {
                    gdi: [ 145, 137, 76 ],
                    nod: [ 169, 27, 26 ]
                }, {
                    gdi: [ 125, 117, 64 ],
                    nod: [ 133, 39, 30 ]
                }, {
                    gdi: [ 109, 101, 56 ],
                    nod: [ 125, 1, 0 ]
                }, {
                    gdi: [ 89, 85, 44 ],
                    nod: [ 96, 41, 24 ]
                }, {
                    gdi: [ 170, 153, 85 ],
                    nod: [ 190, 26, 7 ]
                }, {
                    gdi: [ 194, 174, 97 ],
                    nod: [ 220, 0, 0 ]
                }, {
                    gdi: [ 246, 214, 121 ],
                    nod: [ 255, 0, 1 ]
                }, {
                    gdi: [ 222, 190, 105 ],
                    nod: [ 246, 1, 0 ]
                } ]; else if (type == "vehicle" || type == "infantry") imgData.data[p * 4 + 0] = (r + g + b) / 3, imgData.data[p * 4 + 1] = (r + g + b) / 3, imgData.data[p * 4 + 2] = (r + g + b) / 3;
                for (var i = colorMap.length - 1; i >= 0; i--) r == colorMap[i].gdi[0] && g == colorMap[i].gdi[1] && b == colorMap[i].gdi[2] && (imgData.data[p * 4 + 0] = colorMap[i].nod[0], imgData.data[p * 4 + 1] = colorMap[i].nod[1], imgData.data[p * 4 + 2] = colorMap[i].nod[2]);
            }
            g == 255 && b < 100 && (imgData.data[p * 4] = 0, imgData.data[p * 4 + 1] = 0, imgData.data[p * 4 + 2] = 0);
        }
        spriteContext.globalCompositeOperation = "source-over", spriteContext.putImageData(imgData, 0, 0), spriteContext.globalCompositeOperation = "destination-atop", spriteContext.drawImage(image, 0, 0), context.drawImage(spriteCanvas, 0, 0, width, height, x, y, width, height);
    }
    function angleDiff(angle1, angle2, base) {
        return angle1 = Math.floor(angle1), angle2 = Math.floor(angle2), angle1 >= base / 2 && (angle1 -= base), angle2 >= base / 2 && (angle2 -= base), diff = angle2 - angle1, diff < -base / 2 && (diff += base), diff > base / 2 && (diff -= base), diff;
    }
    function addAngle(angle, increment, base) {
        return angle = Math.round(angle) + increment, angle > base - 1 && (angle -= base), angle < 0 && (angle += base), angle;
    }
    function findAngle(object, unit, base) {
        base || (base = 32), unit || (unit = this), object || (alert(unit.name), alert(unit.orders.type), alert(unit.colliding), alert(unit.collisionWith));
        var dy = object.y - unit.y, dx = object.x - unit.x;
        unit.type == "turret" && (dy -= .5, dx -= .5);
        var angle = base / 2 + Math.round(Math.atan2(dx, dy) * base / (2 * Math.PI));
        return angle < 0 && (angle += base), angle >= base && (angle -= base), angle;
    }
    function shortenPath(path, grid) {
        var nextCellVisible = !0, start = path[0];
        while (nextCellVisible && path.length > 2) {
            var next = path[2];
            if (Math.abs(next.y - start.y) > Math.abs(next.x - start.x)) {
                var slope = (next.x - start.x) / (next.y - start.y), deltaY = .2 * (next.y - start.y) / Math.abs(next.y - start.y), y = deltaY, test = {
                    x: start.x + y * slope,
                    y: start.y + y
                };
                while (nextCellVisible && Math.abs(test.y - next.y) > .3) grid[Math.floor(test.y)][Math.floor(test.x)] > 0 && (nextCellVisible = !1), y += deltaY, test = {
                    x: start.x + y * slope,
                    y: start.y + y
                };
            } else {
                var slope = (next.y - start.y) / (next.x - start.x), deltaX = .2 * (next.x - start.x) / Math.abs(next.x - start.x), x = deltaX, test = {
                    x: start.x + x,
                    y: start.y + slope * x
                };
                while (nextCellVisible && Math.abs(test.x - next.x) >= .3) grid[Math.floor(test.y)][Math.floor(test.x)] > 0 && (nextCellVisible = !1), x += deltaX, test = {
                    x: start.x + x,
                    y: start.y + slope * x
                };
            }
            nextCellVisible && path.splice(1, 1);
        }
    }
    var AStar = function() {
        function diagonalSuccessors($N, $S, $E, $W, N, S, E, W, grid, rows, cols, result, i) {
            return $N && ($E && !grid[N][E] && (result[i++] = {
                x: E,
                y: N
            }), $W && !grid[N][W] && (result[i++] = {
                x: W,
                y: N
            })), $S && ($E && !grid[S][E] && (result[i++] = {
                x: E,
                y: S
            }), $W && !grid[S][W] && (result[i++] = {
                x: W,
                y: S
            })), result;
        }
        function diagonalSuccessorsFree($N, $S, $E, $W, N, S, E, W, grid, rows, cols, result, i) {
            return $N = N > -1, $S = S < rows, $E = E < cols, $W = W > -1, $E && ($N && !grid[N][E] && (result[i++] = {
                x: E,
                y: N
            }), $S && !grid[S][E] && (result[i++] = {
                x: E,
                y: S
            })), $W && ($N && !grid[N][W] && (result[i++] = {
                x: W,
                y: N
            }), $S && !grid[S][W] && (result[i++] = {
                x: W,
                y: S
            })), result;
        }
        function nothingToDo($N, $S, $E, $W, N, S, E, W, grid, rows, cols, result, i) {
            return result;
        }
        function successors(find, x, y, grid, rows, cols) {
            var N = y - 1, S = y + 1, E = x + 1, W = x - 1, $N = N > -1 && !grid[N][x], $S = S < rows && !grid[S][x], $E = E < cols && !grid[y][E], $W = W > -1 && !grid[y][W], result = [], i = 0;
            return $N && (result[i++] = {
                x: x,
                y: N
            }), $E && (result[i++] = {
                x: E,
                y: y
            }), $S && (result[i++] = {
                x: x,
                y: S
            }), $W && (result[i++] = {
                x: W,
                y: y
            }), find($N, $S, $E, $W, N, S, E, W, grid, rows, cols, result, i);
        }
        function diagonal(start, end, f1, f2) {
            return f2(f1(start.x - end.x), f1(start.y - end.y));
        }
        function euclidean(start, end, f1, f2) {
            var x = start.x - end.x, y = start.y - end.y;
            return f2(x * x + y * y);
        }
        function manhattan(start, end, f1, f2) {
            return f1(start.x - end.x) + f1(start.y - end.y);
        }
        function AStar(grid, start, end, f) {
            var cols = grid[0].length, rows = grid.length, limit = cols * rows, f1 = Math.abs, f2 = Math.max, list = {}, result = [], open = [ {
                x: start[0],
                y: start[1],
                f: 0,
                g: 0,
                v: start[0] + start[1] * cols
            } ], length = 1, adj, distance, find, i, j, max, min, current, next;
            end = {
                x: end[0],
                y: end[1],
                v: end[0] + end[1] * cols
            };
            switch (f) {
              case "Diagonal":
                find = diagonalSuccessors;
              case "DiagonalFree":
                distance = diagonal;
                break;
              case "Euclidean":
                find = diagonalSuccessors;
              case "EuclideanFree":
                f2 = Math.sqrt, distance = euclidean;
                break;
              default:
                distance = manhattan, find = nothingToDo;
            }
            find || (find = diagonalSuccessorsFree);
            do {
                max = limit, min = 0;
                for (i = 0; i < length; ++i) (f = open[i].f) < max && (max = f, min = i);
                current = open.splice(min, 1)[0];
                if (current.v != end.v) {
                    --length, next = successors(find, current.x, current.y, grid, rows, cols);
                    for (i = 0, j = next.length; i < j; ++i) (adj = next[i]).p = current, adj.f = adj.g = 0, adj.v = adj.x + adj.y * cols, adj.v in list || (adj.f = (adj.g = current.g + distance(adj, current, f1, f2)) + distance(adj, end, f1, f2), open[length++] = adj, list[adj.v] = 1);
                } else {
                    i = length = 0;
                    do result[i++] = {
                        x: current.x,
                        y: current.y
                    }; while (current = current.p);
                    result.reverse();
                }
            } while (length);
            return result;
        }
        return AStar;
    }();
    game.start(), $("#debugger").toggle(), $("#debug_mode").bind("change", function() {
        game.debugMode = !game.debugMode, $("#debugger").toggle();
    });
});